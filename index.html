<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Battle City Mobile - Retro Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        
        body {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            color: #fff;
            overflow: hidden;
        }
        
        .game-container {
            position: relative;
            margin: 10px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid #ecf0f1;
            background: #000;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            max-width: 100vw;
            max-height: 70vh;
            image-rendering: pixelated;
        }
        
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.85);
            padding: 8px;
            border: 2px solid #f39c12;
            border-radius: 4px;
            font-size: 12px;
            color: #f39c12;
            z-index: 10;
            text-shadow: 1px 1px #000;
        }
        
        .level-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 8px;
            border: 2px solid #3498db;
            border-radius: 4px;
            font-size: 12px;
            color: #3498db;
            z-index: 10;
            text-shadow: 1px 1px #000;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 300px;
            padding: 15px;
            background: rgba(0,0,0,0.9);
            margin-top: 10px;
            border-radius: 8px;
        }
        
        .dpad {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .dpad-btn {
            position: absolute;
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border: 3px solid #ecf0f1;
            border-radius: 8px;
            font-size: 20px;
            color: #ecf0f1;
            cursor: pointer;
            transition: all 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .dpad-btn:active {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .dpad-up { top: 0; left: 40px; width: 40px; height: 40px; }
        .dpad-down { bottom: 0; left: 40px; width: 40px; height: 40px; }
        .dpad-left { top: 40px; left: 0; width: 40px; height: 40px; }
        .dpad-right { top: 40px; right: 0; width: 40px; height: 40px; }
        .dpad-center { top: 40px; left: 40px; width: 40px; height: 40px; background: rgba(52,73,94,0.3); border: 2px solid #555; }
        .fire-btn { width: 60px; height: 60px; border-radius: 50%; font-size: 24px; }
        
        .sound-btn {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border: 3px solid #ecf0f1;
            border-radius: 8px;
            padding: 10px;
            font-size: 16px;
            color: #ecf0f1;
            cursor: pointer;
        }
        
        .sound-btn:active {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        
        .start-screen, .game-over, .pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(44,62,80,0.95), rgba(52,73,94,0.95));
            padding: 20px;
            border: 3px solid #f39c12;
            border-radius: 8px;
            text-align: center;
            display: none;
            box-shadow: 0 0 30px rgba(243,156,18,0.5);
            z-index: 20;
            font-size: 12px;
            max-width: 80%;
        }
        
        .start-screen h2, .game-over h2, .pause-menu h2 {
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 2px 2px #000;
        }
        
        .restart-btn, .start-btn, .resume-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: #2c3e50;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .restart-btn:hover, .start-btn:hover, .resume-btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
            transform: translateY(-2px);
        }
        
        @media (max-width: 768px) {
            .controls { padding: 10px; }
            .dpad { width: 100px; height: 100px; }
            .dpad-btn { font-size: 16px; }
            .dpad-up, .dpad-down, .dpad-left, .dpad-right { width: 30px; height: 30px; }
            .dpad-center { top: 35px; left: 35px; width: 30px; height: 30px; }
            .dpad-up { left: 35px; }
            .dpad-down { left: 35px; }
            .fire-btn { width: 50px; height: 50px; font-size: 20px; }
            .start-screen, .game-over, .pause-menu { padding: 15px; font-size: 10px; }
            .start-screen h2, .game-over h2, .pause-menu h2 { font-size: 18px; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="520" height="520"></canvas>
        
        <div class="hud">
            <div>üèÜ –û—á–∫–∏: <span id="score">0</span></div>
            <div>üíö –ñ–∏–∑–Ω–∏: <span id="lives">3</span></div>
            <div>‚≠ê –£—Ä–æ–≤–µ–Ω—å: <span id="powerLevel">0</span></div>
            <div id="powerUpStatus"></div>
            <div>ü•á –†–µ–∫–æ—Ä–¥: <span id="highScore">0</span></div>
        </div>
        
        <div class="level-info">
            <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
            <div>–í—Ä–∞–≥–∏: <span id="enemies">10</span></div>
            <div id="levelType">–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π</div>
        </div>
        
        <div class="start-screen" id="startScreen">
            <h2>Battle City</h2>
            <p>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ D-Pad –∏–ª–∏ WASD –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è, –∫–Ω–æ–ø–∫—É –æ–≥–Ω—è –∏–ª–∏ –ø—Ä–æ–±–µ–ª –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã.</p>
            <p>–¶–µ–ª—å: —É–Ω–∏—á—Ç–æ–∂—å—Ç–µ –≤—Å–µ –≤—Ä–∞–∂–µ—Å–∫–∏–µ —Ç–∞–Ω–∫–∏ –∏ –∑–∞—â–∏—Ç–∏—Ç–µ –±–∞–∑—É (ü¶Ö).</p>
            <p>–ë–æ–Ω—É—Å—ã: ‚≠ê —É–ª—É—á—à–µ–Ω–∏–µ, üõ°Ô∏è —â–∏—Ç, üí£ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤, üöó –∂–∏–∑–Ω—å, ‚è∞ –∑–∞–º–æ—Ä–æ–∑–∫–∞, ‚ö° —Å–∫–æ—Ä–æ—Å—Ç—å.</p>
            <button class="start-btn">üöÄ –ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2>üéØ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h2>
            <div>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á—ë—Ç: <span id="finalScore">0</span></div>
            <div>–†–µ–∫–æ—Ä–¥: <span id="finalHighScore">0</span></div>
            <button class="restart-btn">üöÄ –ù–û–í–ê–Ø –ò–ì–†–ê</button>
        </div>
        
        <div class="pause-menu" id="pauseMenu">
            <h2>‚è∏Ô∏è –ü–ê–£–ó–ê</h2>
            <button class="resume-btn">‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button class="restart-btn">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <div class="controls">
        <div class="dpad">
            <button class="dpad-btn dpad-up" data-direction="up">‚ñ≤</button>
            <button class="dpad-btn dpad-down" data-direction="down">‚ñº</button>
            <button class="dpad-btn dpad-left" data-direction="left">‚óÄ</button>
            <button class="dpad-btn dpad-right" data-direction="right">‚ñ∂</button>
            <div class="dpad-center"></div>
        </div>
        <button class="dpad-btn fire-btn" id="fireButton">üí•</button>
        <button class="sound-btn" id="soundToggle">üîä</button>
    </div>

    <script>
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏–≥—Ä—ã
        const BLOCK_SIZE = 20;
        const GRID_WIDTH = 26;
        const GRID_HEIGHT = 26;
        
        const ENEMY_TYPES = {
            BASIC: { speed: 1, health: 1, points: 100, color: '#FF4444', size: 18 },
            FAST: { speed: 2, health: 1, points: 200, color: '#FF8844', size: 16 },
            POWER: { speed: 1, health: 3, points: 300, color: '#44FF44', size: 20 },
            ARMOR: { speed: 1, health: 2, points: 400, color: '#FFFF44', size: 19 }
        };

        const POWERUP_TYPES = {
            STAR: { name: '–ó–≤–µ–∑–¥–∞', effect: 'upgrade', duration: -1, icon: '‚≠ê' },
            HELMET: { name: '–®–ª–µ–º', effect: 'shield', duration: 8000, icon: 'üõ°Ô∏è' },
            SHOVEL: { name: '–õ–æ–ø–∞—Ç–∞', effect: 'fortify', duration: 15000, icon: 'üõ†Ô∏è' },
            GRENADE: { name: '–ì—Ä–∞–Ω–∞—Ç–∞', effect: 'destroy_all', duration: -1, icon: 'üí£' },
            TANK: { name: '–¢–∞–Ω–∫', effect: 'extra_life', duration: -1, icon: 'üöó' },
            CLOCK: { name: '–ß–∞—Å—ã', effect: 'freeze', duration: 6000, icon: '‚è∞' },
            SPEED: { name: '–°–∫–æ—Ä–æ—Å—Ç—å', effect: 'speed_boost', duration: 10000, icon: '‚ö°' }
        };

        // –ó–∞–≥—Ä—É–∑–∫–∞ –∑–≤—É–∫–æ–≤
        const sounds = {
            move: new Audio('data:audio/wav;base64,//snd_data_move'),
            shoot: new Audio('data:audio/wav;base64,//snd_data_shoot'),
            explosion: new Audio('data:audio/wav;base64,//snd_data_explosion'),
            powerUp: new Audio('data:audio/wav;base64,//snd_data_powerup'),
            gameOver: new Audio('data:audio/wav;base64,//snd_data_gameover')
        };
        let soundEnabled = true;

        // –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –∏–≥—Ä—ã
        class TankGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.highScore = localStorage.getItem('battleCityHighScore') || 0;
                this.gameState = 'start';
                this.enemiesRemaining = 10;
                this.enemiesOnField = 0;
                this.maxEnemiesOnField = 3;
                this.enemySpawnTimer = 0;
                this.enemySpawnDelay = 120;
                
                this.bullets = [];
                this.enemyBullets = [];
                this.enemies = [];
                this.explosions = [];
                this.powerUps = [];
                this.walls = [];
                this.grass = [];
                this.water = [];
                this.particles = [];
                this.enemyBases = [];
                
                this.enemySpawnPoints = [
                    { x: BLOCK_SIZE, y: BLOCK_SIZE },
                    { x: 12 * BLOCK_SIZE, y: BLOCK_SIZE },
                    { x: 23 * BLOCK_SIZE, y: BLOCK_SIZE }
                ];
                
                this.player = new Tank(12 * BLOCK_SIZE, 22 * BLOCK_SIZE, 'player');
                this.playerBase = new Base(12 * BLOCK_SIZE, 24 * BLOCK_SIZE, 'player');
                
                this.playerPowerUps = {
                    shield: 180,
                    level: 0,
                    frozen: false,
                    speedBoost: 0
                };
                
                this.touchControls = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    fire: false
                };
                
                this.levelLayouts = [
                    this.createLevel1,
                    this.createLevel2,
                    this.createLevel3
                ];
                
                this.bindEvents();
                this.gameLoop();
            }
            
            start() {
                this.gameState = 'playing';
                this.init();
                document.getElementById('startScreen').style.display = 'none';
                if (soundEnabled) sounds.gameOver.play();
                setTimeout(() => this.forceSpawnEnemies(), 1000);
            }
            
            init() {
                this.createLevel();
                this.updateHUD();
                this.enemySpawnTimer = 0;
            }
            
            forceSpawnEnemies() {
                for (let i = 0; i < 3; i++) {
                    if (this.enemiesRemaining > 0) {
                        this.spawnEnemy();
                    }
                }
            }
            
            createLevel() {
                this.walls = [];
                this.grass = [];
                this.water = [];
                this.enemyBases = [];
                
                const layoutIndex = (this.level - 1) % this.levelLayouts.length;
                this.levelLayouts[layoutIndex].call(this);
                this.createBorders();
                this.createPlayerBaseProtection();
                
                document.getElementById('levelType').textContent = `–£—Ä–æ–≤–µ–Ω—å ${layoutIndex + 1}`;
            }
            
            createLevel1() {
                this.enemyBases.push(new Base(2 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                this.enemyBases.push(new Base(22 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                
                const obstacles = [
                    [5, 5], [6, 5], [7, 5], [17, 5], [18, 5], [19, 5],
                    [5, 8], [6, 8], [7, 8], [17, 8], [18, 8], [19, 8],
                    [11, 10], [12, 10], [13, 10], [11, 11], [12, 11], [13, 11],
                    [3, 15], [4, 15], [5, 15], [19, 15], [20, 15], [21, 15]
                ];
                
                obstacles.forEach(([x, y]) => {
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: true, health: 1, maxHealth: 1
                    });
                });
                
                const waterAreas = [[9, 12], [10, 12], [14, 12], [15, 12]];
                waterAreas.forEach(([x, y]) => {
                    this.water.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
                
                const grassAreas = [[2, 7], [3, 7], [21, 7], [22, 7], [8, 14], [9, 14], [15, 14], [16, 14]];
                grassAreas.forEach(([x, y]) => {
                    this.grass.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
            }
            
            createLevel2() {
                this.enemyBases.push(new Base(12 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                
                const obstacles = [
                    [3, 3], [4, 3], [20, 3], [21, 3],
                    [8, 8], [9, 8], [10, 8], [14, 8], [15, 8], [16, 8],
                    [3, 12], [4, 12], [20, 12], [21, 12],
                    [10, 16], [11, 16], [12, 16], [13, 16], [14, 16]
                ];
                
                obstacles.forEach(([x, y]) => {
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: true, health: 1, maxHealth: 1
                    });
                });
                
                const waterAreas = [[6, 6], [7, 6], [17, 6], [18, 6]];
                waterAreas.forEach(([x, y]) => {
                    this.water.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
                
                const grassAreas = [[5, 10], [6, 10], [18, 10], [19, 10]];
                grassAreas.forEach(([x, y]) => {
                    this.grass.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
            }
            
            createLevel3() {
                this.enemyBases.push(new Base(2 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                this.enemyBases.push(new Base(22 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                
                const obstacles = [
                    [5, 4], [6, 4], [7, 4], [17, 4], [18, 4], [19, 4],
                    [10, 8], [11, 8], [12, 8], [13, 8], [14, 8],
                    [5, 12], [6, 12], [7, 12], [17, 12], [18, 12], [19, 12],
                    [10, 16], [11, 16], [12, 16], [13, 16], [14, 16]
                ];
                
                obstacles.forEach(([x, y]) => {
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: true, health: 1, maxHealth: 1
                    });
                });
                
                const waterAreas = [[8, 10], [9, 10], [15, 10], [16, 10]];
                waterAreas.forEach(([x, y]) => {
                    this.water.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
                
                const grassAreas = [[2, 6], [3, 6], [21, 6], [22, 6]];
                grassAreas.forEach(([x, y]) => {
                    this.grass.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
            }
            
            createBorders() {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (x < 1 || (x > 2 && x < 11) || (x > 13 && x < 22) || x > 23) {
                        this.walls.push({
                            x: x * BLOCK_SIZE, y: 0,
                            destructible: false, health: -1
                        });
                    }
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: (GRID_HEIGHT-1) * BLOCK_SIZE,
                        destructible: false, health: -1
                    });
                }
                
                for (let y = 1; y < GRID_HEIGHT-1; y++) {
                    this.walls.push({
                        x: 0, y: y * BLOCK_SIZE,
                        destructible: false, health: -1
                    });
                    this.walls.push({
                        x: (GRID_WIDTH-1) * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: false, health: -1
                    });
                }
            }
            
            createPlayerBaseProtection() {
                const baseProtection = [
                    [11, 22], [12, 22], [13, 22], [11, 23], [13, 23], [11, 25], [13, 25]
                ];
                
                baseProtection.forEach(([x, y]) => {
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: true, health: 1, maxHealth: 1
                    });
                });
            }
            
            bindEvents() {
                this.keys = {};
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'KeyP') this.togglePause();
                    if (e.code === 'Space' && this.gameState === 'playing') this.touchControls.fire = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    if (e.code === 'Space') this.touchControls.fire = false;
                });
                
                const dpadButtons = document.querySelectorAll('.dpad-btn');
                dpadButtons.forEach(btn => {
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction || (btn.id === 'fireButton' ? 'fire' : null);
                        if (direction) this.touchControls[direction] = true;
                    });
                    
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction || (btn.id === 'fireButton' ? 'fire' : null);
                        if (direction) this.touchControls[direction] = false;
                    });
                    
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction || (btn.id === 'fireButton' ? 'fire' : null);
                        if (direction) this.touchControls[direction] = true;
                    });
                    
                    btn.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction || (btn.id === 'fireButton' ? 'fire' : null);
                        if (direction) this.touchControls[direction] = false;
                    });
                });
                
                // Add event listeners for buttons
                document.querySelector('.start-btn').addEventListener('click', () => this.start());
                document.querySelectorAll('.restart-btn').forEach(btn => btn.addEventListener('click', () => this.restart()));
                document.querySelector('.resume-btn').addEventListener('click', () => this.togglePause());
                
                document.getElementById('soundToggle').addEventListener('click', () => {
                    soundEnabled = !soundEnabled;
                    document.getElementById('soundToggle').textContent = soundEnabled ? 'üîä' : 'üîá';
                });
                
                document.addEventListener('mouseup', () => {
                    Object.keys(this.touchControls).forEach(key => {
                        this.touchControls[key] = false;
                    });
                });
            }
            
            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    document.getElementById('pauseMenu').style.display = 'block';
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    document.getElementById('pauseMenu').style.display = 'none';
                }
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                this.updatePowerUps();
                this.updateEnemySpawn();
                
                this.player.update(this);
                
                if (!this.playerPowerUps.frozen) {
                    this.enemies.forEach(enemy => enemy.update(this));
                }
                
                this.bullets = this.bullets.filter(bullet => bullet.update(this));
                this.enemyBullets = this.enemyBullets.filter(bullet => bullet.update(this));
                this.explosions = this.explosions.filter(explosion => explosion.update());
                this.particles = this.particles.filter(particle => particle.update());
                
                this.checkCollisions();
                this.checkGameConditions();
            }
            
            updatePowerUps() {
                if (this.playerPowerUps.shield > 0) this.playerPowerUps.shield--;
                if (this.playerPowerUps.speedBoost > 0) {
                    this.playerPowerUps.speedBoost--;
                    if (this.playerPowerUps.speedBoost <= 0) {
                        this.player.speed = this.player.level >= 2 ? 3 : 2; // Reset speed
                    }
                }
                if (this.playerPowerUps.frozen && Date.now() > this.playerPowerUps.frozenUntil) {
                    this.playerPowerUps.frozen = false;
                }
                this.updatePowerUpDisplay();
            }
            
            updatePowerUpDisplay() {
                const statusElement = document.getElementById('powerUpStatus');
                let status = '';
                if (this.playerPowerUps.shield > 0) status += 'üõ°Ô∏è ';
                if (this.playerPowerUps.level > 0) status += '‚≠ê'.repeat(this.playerPowerUps.level) + ' ';
                if (this.playerPowerUps.frozen) status += '‚ùÑÔ∏è ';
                if (this.playerPowerUps.speedBoost > 0) status += '‚ö° ';
                statusElement.textContent = status;
                document.getElementById('powerLevel').textContent = this.playerPowerUps.level;
            }
            
            updateEnemySpawn() {
                if (this.enemiesRemaining > 0 && this.enemiesOnField < this.maxEnemiesOnField) {
                    this.enemySpawnTimer++;
                    if (this.enemySpawnTimer >= this.enemySpawnDelay) {
                        this.spawnEnemy();
                        this.enemySpawnTimer = 0;
                    }
                }
            }
            
            spawnEnemy() {
                if (this.enemiesRemaining <= 0) return;
                
                const spawnPoint = this.enemySpawnPoints[Math.floor(Math.random() * this.enemySpawnPoints.length)];
                
                if (this.checkCollision(spawnPoint.x, spawnPoint.y, BLOCK_SIZE, BLOCK_SIZE)) {
                    return;
                }
                
                let enemyType = 'BASIC';
                const rand = Math.random();
                if (rand < 0.15 * (1 + this.level * 0.1)) enemyType = 'POWER';
                else if (rand < 0.35 * (1 + this.level * 0.1)) enemyType = 'ARMOR';
                else if (rand < 0.6 * (1 + this.level * 0.1)) enemyType = 'FAST';
                
                const hasPowerUp = (10 - this.enemiesRemaining + 1) % 3 === 0;
                
                const enemy = new Tank(spawnPoint.x, spawnPoint.y, 'enemy', enemyType, hasPowerUp);
                this.enemies.push(enemy);
                this.enemiesRemaining--;
                this.enemiesOnField++;
                
                this.explosions.push(new Explosion(spawnPoint.x, spawnPoint.y, 'spawn'));
                if (soundEnabled) sounds.explosion.play();
            }
            
            checkCollisions() {
                this.bullets.forEach((bullet, bulletIndex) => {
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (this.isColliding(bullet, enemy)) {
                            this.bullets.splice(bulletIndex, 1);
                            enemy.hit();
                            if (enemy.health <= 0) {
                                if (enemy.hasPowerUp) this.createPowerUp(enemy.x, enemy.y);
                                this.enemies.splice(enemyIndex, 1);
                                this.enemiesOnField--;
                                this.explosions.push(new Explosion(enemy.x, enemy.y));
                                this.createParticles(enemy.x + BLOCK_SIZE/2, enemy.y + BLOCK_SIZE/2, '#FF6600');
                                this.score += ENEMY_TYPES[enemy.enemyType].points;
                                if (soundEnabled) sounds.explosion.play();
                                this.updateHUD();
                            }
                        }
                    });
                });
                
                this.bullets.forEach((bullet, bulletIndex) => {
                    this.enemyBases.forEach((base, baseIndex) => {
                        if (this.isColliding(bullet, base)) {
                            this.bullets.splice(bulletIndex, 1);
                            base.hit();
                            this.explosions.push(new Explosion(base.x, base.y));
                            this.score += 1000;
                            if (soundEnabled) sounds.explosion.play();
                            this.updateHUD();
                            if (base.health <= 0) this.enemyBases.splice(baseIndex, 1);
                        }
                    });
                });
                
                this.enemyBullets.forEach((bullet, bulletIndex) => {
                    if (this.isColliding(bullet, this.player)) {
                        this.enemyBullets.splice(bulletIndex, 1);
                        if (this.playerPowerUps.shield > 0) {
                            this.playerPowerUps.shield = 0;
                        } else {
                            this.player.hit();
                            this.explosions.push(new Explosion(this.player.x, this.player.y));
                            this.createParticles(this.player.x + BLOCK_SIZE/2, this.player.y + BLOCK_SIZE/2, '#00FF00');
                            this.lives--;
                            this.playerPowerUps.shield = 120;
                            if (soundEnabled) sounds.explosion.play();
                            this.updateHUD();
                        }
                    }
                });
                
                [...this.bullets, ...this.enemyBullets].forEach((bullet, index, array) => {
                    if (this.isColliding(bullet, this.playerBase)) {
                        array.splice(index, 1);
                        this.playerBase.hit();
                        this.explosions.push(new Explosion(this.playerBase.x, this.playerBase.y));
                        if (soundEnabled) sounds.explosion.play();
                        if (this.playerBase.health <= 0) this.gameOver();
                    }
                });
                
                [...this.bullets, ...this.enemyBullets].forEach((bullet, index, array) => {
                    this.walls.forEach((wall, wallIndex) => {
                        if (this.isColliding(bullet, wall)) {
                            array.splice(index, 1);
                            if (wall.destructible) {
                                wall.health--;
                                if (wall.health <= 0) {
                                    this.walls.splice(wallIndex, 1);
                                    this.explosions.push(new Explosion(wall.x, wall.y, 'small'));
                                    this.createParticles(wall.x + BLOCK_SIZE/2, wall.y + BLOCK_SIZE/2, '#8B4513');
                                    if (soundEnabled) sounds.explosion.play();
                                }
                            }
                        }
                    });
                });
                
                this.powerUps.forEach((powerUp, index) => {
                    if (this.isColliding(this.player, powerUp)) {
                        this.powerUps.splice(index, 1);
                        this.applyPowerUp(powerUp.type);
                        this.explosions.push(new Explosion(powerUp.x, powerUp.y, 'pickup'));
                        this.score += 500;
                        if (soundEnabled) sounds.powerUp.play();
                        this.updateHUD();
                    }
                });
            }
            
            createPowerUp(x, y) {
                const types = Object.keys(POWERUP_TYPES);
                const randomType = types[Math.floor(Math.random() * types.length)];
                this.powerUps.push(new PowerUp(x, y, randomType));
            }
            
            applyPowerUp(type) {
                const powerUp = POWERUP_TYPES[type];
                switch (powerUp.effect) {
                    case 'upgrade':
                        this.playerPowerUps.level = Math.min(3, this.playerPowerUps.level + 1);
                        this.player.upgrade();
                        break;
                    case 'shield':
                        this.playerPowerUps.shield = powerUp.duration / 16.67;
                        break;
                    case 'fortify':
                        this.createPlayerBaseProtection();
                        break;
                    case 'destroy_all':
                        this.destroyAllEnemies();
                        break;
                    case 'extra_life':
                        this.lives++;
                        break;
                    case 'freeze':
                        this.playerPowerUps.frozen = true;
                        this.playerPowerUps.frozenUntil = Date.now() + powerUp.duration;
                        break;
                    case 'speed_boost':
                        this.playerPowerUps.speedBoost = powerUp.duration / 16.67;
                        this.player.speed = 4;
                        break;
                }
            }
            
            destroyAllEnemies() {
                this.enemies.forEach(enemy => {
                    this.explosions.push(new Explosion(enemy.x, enemy.y));
                    this.score += ENEMY_TYPES[enemy.enemyType].points;
                    if (soundEnabled) sounds.explosion.play();
                });
                this.enemiesOnField = 0;
                this.enemies = [];
                this.updateHUD();
            }
            
            createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }
            
            checkGameConditions() {
                if (this.lives <= 0 || this.playerBase.health <= 0) {
                    this.gameOver();
                }
                
                if ((this.enemiesRemaining === 0 && this.enemies.length === 0) || this.enemyBases.length === 0) {
                    this.nextLevel();
                }
            }
            
            nextLevel() {
                this.level++;
                this.enemiesRemaining = Math.min(20, 10 + this.level * 3);
                this.enemiesOnField = 0;
                this.powerUps = [];
                this.updateHUD();
                this.createLevel();
                this.player.x = 12 * BLOCK_SIZE;
                this.player.y = 22 * BLOCK_SIZE;
                this.playerBase = new Base(12 * BLOCK_SIZE, 24 * BLOCK_SIZE, 'player');
                setTimeout(() => this.forceSpawnEnemies(), 500);
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('battleCityHighScore', this.highScore);
                }
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalHighScore').textContent = this.highScore;
                document.getElementById('gameOver').style.display = 'block';
                if (soundEnabled) sounds.gameOver.play();
            }
            
            restart() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.enemiesRemaining = 10;
                this.enemiesOnField = 0;
                this.gameState = 'playing';
                this.bullets = [];
                this.enemyBullets = [];
                this.enemies = [];
                this.explosions = [];
                this.particles = [];
                this.powerUps = [];
                this.playerPowerUps = { shield: 180, level: 0, frozen: false, speedBoost: 0 };
                this.player = new Tank(12 * BLOCK_SIZE, 22 * BLOCK_SIZE, 'player');
                this.playerBase = new Base(12 * BLOCK_SIZE, 24 * BLOCK_SIZE, 'player');
                this.init();
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('pauseMenu').style.display = 'none';
                setTimeout(() => this.forceSpawnEnemies(), 1000);
            }
            
            updateHUD() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                document.getElementById('enemies').textContent = this.enemiesRemaining + this.enemiesOnField;
                document.getElementById('highScore').textContent = this.highScore;
            }
            
            isColliding(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            checkCollision(x, y, width, height) {
                const testObj = {x, y, width, height};
                if (this.walls.some(wall => this.isColliding(testObj, wall))) return true;
                if (this.water.some(water => this.isColliding(testObj, water))) return true;
                if (this.isColliding(testObj, this.playerBase)) return true;
                if (this.enemyBases.some(base => this.isColliding(testObj, base))) return true;
                if (this.enemies.some(enemy => this.isColliding(testObj, enemy))) return true;
                return false;
            }
            
            findPath(startX, startY, targetX, targetY) {
                const grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(0));
                this.walls.forEach(wall => {
                    grid[Math.floor(wall.y / BLOCK_SIZE)][Math.floor(wall.x / BLOCK_SIZE)] = 1;
                });
                this.water.forEach(water => {
                    grid[Math.floor(water.y / BLOCK_SIZE)][Math.floor(water.x / BLOCK_SIZE)] = 1;
                });
                
                const queue = [[startX, startY, []]];
                const visited = new Set();
                const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];
                
                while (queue.length) {
                    const [x, y, path] = queue.shift();
                    const gridX = Math.floor(x / BLOCK_SIZE);
                    const gridY = Math.floor(y / BLOCK_SIZE);
                    
                    if (gridX === Math.floor(targetX / BLOCK_SIZE) && gridY === Math.floor(targetY / BLOCK_SIZE)) {
                        return path.length ? path[0] : null;
                    }
                    
                    const key = `${gridX},${gridY}`;
                    if (visited.has(key) || grid[gridY][gridX] === 1) continue;
                    visited.add(key);
                    
                    for (let i = 0; i < 4; i++) {
                        const [dx, dy] = directions[i];
                        const newX = x + dx * BLOCK_SIZE;
                        const newY = y + dy * BLOCK_SIZE;
                        if (newX >= 0 && newX < this.width && newY >= 0 && newY < this.height) {
                            queue.push([newX, newY, [...path, i]]);
                        }
                    }
                }
                return null;
            }
            
            render() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.water.forEach(water => this.drawWater(water));
                this.walls.forEach(wall => this.drawWall(wall));
                this.playerBase.render(this.ctx);
                this.enemyBases.forEach(base => base.render(this.ctx));
                this.player.render(this.ctx);
                this.enemies.forEach(enemy => enemy.render(this.ctx));
                this.grass.forEach(grass => this.drawGrass(grass));
                this.bullets.forEach(bullet => bullet.render(this.ctx));
                this.enemyBullets.forEach(bullet => bullet.render(this.ctx));
                this.powerUps.forEach(powerUp => powerUp.render(this.ctx));
                this.explosions.forEach(explosion => explosion.render(this.ctx));
                this.particles.forEach(particle => particle.render(this.ctx));
                
                if (this.gameState === 'start') {
                    document.getElementById('startScreen').style.display = 'block';
                } else if (this.gameState === 'paused') {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }
            }
            
            drawWall(wall) {
                if (wall.destructible) {
                    this.ctx.fillStyle = '#A52A2A';
                    this.ctx.fillRect(wall.x, wall.y, BLOCK_SIZE, BLOCK_SIZE);
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillRect(wall.x + 2, wall.y + 2, 4, 4);
                    this.ctx.fillRect(wall.x + 14, wall.y + 2, 4, 4);
                    this.ctx.fillRect(wall.x + 2, wall.y + 14, 4, 4);
                    this.ctx.fillRect(wall.x + 14, wall.y + 14, 4, 4);
                } else {
                    this.ctx.fillStyle = '#808080';
                    this.ctx.fillRect(wall.x, wall.y, BLOCK_SIZE, BLOCK_SIZE);
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillRect(wall.x + 4, wall.y + 4, 12, 12);
                }
            }
            
            drawGrass(grass) {
                this.ctx.fillStyle = '#00FF00';
                this.ctx.fillRect(grass.x, grass.y, BLOCK_SIZE, BLOCK_SIZE);
                this.ctx.fillStyle = '#008000';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        if ((i + j) % 2 === 0) {
                            this.ctx.fillRect(grass.x + i * 5, grass.y + j * 5, 5, 5);
                        }
                    }
                }
            }
            
            drawWater(water) {
                const time = Date.now() * 0.003;
                const offset = Math.sin(time) * 2;
                this.ctx.fillStyle = '#0000FF';
                this.ctx.fillRect(water.x, water.y, BLOCK_SIZE, BLOCK_SIZE);
                this.ctx.fillStyle = '#00FFFF';
                this.ctx.fillRect(water.x + offset, water.y + 4, BLOCK_SIZE - 8, 4);
                this.ctx.fillRect(water.x + 4, water.y + offset, 4, BLOCK_SIZE - 8);
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        class Tank {
            constructor(x, y, type, enemyType = 'BASIC', hasPowerUp = false) {
                this.x = x;
                this.y = y;
                this.width = BLOCK_SIZE;
                this.height = BLOCK_SIZE;
                this.type = type;
                this.enemyType = enemyType;
                this.hasPowerUp = hasPowerUp;
                this.direction = type === 'player' ? 0 : 2;
                this.lastShot = 0;
                this.shootCooldown = type === 'player' ? 400 : 600;
                this.level = 0;
                this.animationFrame = 0;
                
                if (type === 'player') {
                    this.speed = 2;
                    this.health = 1;
                    this.maxBullets = 1;
                } else {
                    const stats = ENEMY_TYPES[enemyType];
                    this.speed = stats.speed;
                    this.health = stats.health;
                    this.maxHealth = stats.health;
                    this.color = stats.color;
                    this.maxBullets = 1;
                    this.size = stats.size;
                    this.aiTimer = 0;
                    this.aiDirection = this.direction;
                    this.aiChangeTimer = 0;
                    this.targetDirection = this.direction;
                }
            }
            
            upgrade() {
                this.level = Math.min(3, this.level + 1);
                if (this.level >= 1) this.maxBullets = 2;
                if (this.level >= 2) this.speed = 3;
                if (this.level >= 3) this.shootCooldown = 250;
            }
            
            update(game) {
                this.animationFrame++;
                if (this.type === 'player') {
                    this.updatePlayer(game);
                } else {
                    this.updateAI(game);
                }
                
                if (this.type === 'enemy' && Date.now() - this.lastShot > this.shootCooldown) {
                    if (game.enemyBullets.length < 6) {
                        this.shoot(game);
                    }
                }
            }
            
            updatePlayer(game) {
                let newX = this.x;
                let newY = this.y;
                let moved = false;
                
                if (game.keys['KeyW'] || game.keys['ArrowUp'] || game.touchControls.up) {
                    this.direction = 0;
                    newY -= (game.playerPowerUps.speedBoost > 0 ? 4 : this.speed);
                    moved = true;
                }
                if (game.keys['KeyS'] || game.keys['ArrowDown'] || game.touchControls.down) {
                    this.direction = 2;
                    newY += (game.playerPowerUps.speedBoost > 0 ? 4 : this.speed);
                    moved = true;
                }
                if (game.keys['KeyA'] || game.keys['ArrowLeft'] || game.touchControls.left) {
                    this.direction = 3;
                    newX -= (game.playerPowerUps.speedBoost > 0 ? 4 : this.speed);
                    moved = true;
                }
                if (game.keys['KeyD'] || game.keys['ArrowRight'] || game.touchControls.right) {
                    this.direction = 1;
                    newX += (game.playerPowerUps.speedBoost > 0 ? 4 : this.speed);
                    moved = true;
                }
                
                if (game.touchControls.fire && Date.now() - this.lastShot > this.shootCooldown) {
                    if (game.bullets.length < this.maxBullets) {
                        this.shoot(game);
                        if (soundEnabled) sounds.shoot.play();
                    }
                }
                
                if (moved && soundEnabled && this.animationFrame % 10 === 0) {
                    sounds.move.play();
                }
                
                if (!game.checkCollision(newX, newY, this.width, this.height)) {
                    this.x = newX;
                    this.y = newY;
                }
            }
            
            updateAI(game) {
                this.aiTimer++;
                this.aiChangeTimer++;
                
                if (this.aiChangeTimer > 60 + Math.random() * 60) {
                    const target = Math.random() < 0.7 ? { x: game.playerBase.x, y: game.playerBase.y } : 
                                  Math.random() < 0.5 ? { x: game.player.x, y: game.player.y } : 
                                  { x: Math.random() * game.width, y: Math.random() * game.height };
                    const path = game.findPath(this.x, this.y, target.x, target.y);
                    if (path !== null) this.targetDirection = path;
                    this.aiChangeTimer = 0;
                }
                
                let newX = this.x;
                let newY = this.y;
                
                this.direction = this.targetDirection;
                
                switch (this.direction) {
                    case 0: newY -= this.speed; break;
                    case 1: newX += this.speed; break;
                    case 2: newY += this.speed; break;
                    case 3: newX -= this.speed; break;
                }
                
                if (!game.checkCollision(newX, newY, this.width, this.height)) {
                    this.x = newX;
                    this.y = newY;
                } else {
                    this.targetDirection = Math.floor(Math.random() * 4);
                    this.aiChangeTimer = 0;
                }
            }
            
            shoot(game) {
                this.lastShot = Date.now();
                let bulletX = this.x + this.width / 2;
                let bulletY = this.y + this.height / 2;
                
                switch (this.direction) {
                    case 0: bulletY = this.y; break;
                    case 1: bulletX = this.x + this.width; break;
                    case 2: bulletY = this.y + this.height; break;
                    case 3: bulletX = this.x; break;
                }
                
                const bullet = new Bullet(bulletX, bulletY, this.direction, this.type);
                if (this.type === 'player') {
                    game.bullets.push(bullet);
                } else {
                    game.enemyBullets.push(bullet);
                }
            }
            
            hit() {
                this.health--;
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.direction * Math.PI / 2);
                
                const tankSize = this.type === 'player' ? BLOCK_SIZE - 2 : (this.size || BLOCK_SIZE - 4);
                
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-tankSize/2 - 1, -tankSize/2 - 1, tankSize + 2, 4);
                ctx.fillRect(-tankSize/2 - 1, tankSize/2 - 3, tankSize + 2, 4);
                
                let bodyColor = this.type === 'player' ? '#FFD700' : this.color;
                ctx.fillStyle = bodyColor;
                ctx.fillRect(-tankSize/2, -tankSize/2, tankSize, tankSize);
                
                ctx.fillStyle = '#2F2F2F';
                ctx.beginPath();
                ctx.arc(0, 0, tankSize/4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#2F2F2F';
                ctx.fillRect(-2, -tankSize/2 - 4, 4, 8);
                
                if (this.type === 'enemy' && this.health < this.maxHealth) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(-tankSize/2, -tankSize/2 - 6, tankSize, 2);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(-tankSize/2, -tankSize/2 - 6, (tankSize * this.health) / this.maxHealth, 2);
                }
                
                if (this.type === 'enemy' && this.hasPowerUp) {
                    const pulse = Math.sin(this.animationFrame * 0.2) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '8px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚òÖ', 0, -tankSize/2 - 10);
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
                
                if (this.type === 'player' && game.playerPowerUps.shield > 0) {
                    const shieldAlpha = (Math.sin(Date.now() * 0.03) + 1) / 2;
                    ctx.globalAlpha = shieldAlpha * 0.8;
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2 + 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        class Bullet {
            constructor(x, y, direction, owner) {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 4;
                this.direction = direction;
                this.speed = 6;
                this.owner = owner;
                this.vx = 0;
                this.vy = 0;
                
                switch (direction) {
                    case 0: this.vy = -this.speed; break;
                    case 1: this.vx = this.speed; break;
                    case 2: this.vy = this.speed; break;
                    case 3: this.vx = -this.speed; break;
                }
            }
            
            update(game) {
                this.x += this.vx;
                this.y += this.vy;
                return this.x > 0 && this.x < game.width && this.y > 0 && this.y < game.height;
            }
            
            render(ctx) {
                ctx.fillStyle = this.owner === 'player' ? '#FFFFFF' : '#FF6600';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
            }
        }
        
        class Explosion {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = type === 'spawn' ? 20 : type === 'small' ? 12 : type === 'pickup' ? 8 : 20;
                this.maxLife = this.life;
                this.radius = 0;
                this.maxRadius = type === 'small' ? 12 : type === 'pickup' ? 8 : 20;
            }
            
            update() {
                this.life--;
                this.radius = ((this.maxLife - this.life) / this.maxLife) * this.maxRadius;
                return this.life > 0;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.type === 'spawn' ? '#00FFFF' : this.type === 'pickup' ? '#FFD700' : '#FF6600';
                ctx.beginPath();
                ctx.arc(this.x + BLOCK_SIZE/2, this.y + BLOCK_SIZE/2, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 15;
                this.maxLife = 15;
                this.color = color;
                this.size = Math.random() * 2 + 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = BLOCK_SIZE;
                this.height = BLOCK_SIZE;
                this.type = type;
                this.animationTimer = 0;
                this.lifeTime = 400;
            }
            
            update() {
                this.animationTimer++;
                this.lifeTime--;
                return this.lifeTime > 0;
            }
            
            render(ctx) {
                if (this.lifeTime < 120 && Math.floor(this.animationTimer / 8) % 2) return;
                
                const powerUp = POWERUP_TYPES[this.type];
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px Press Start 2P';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerUp.icon, this.x + this.width/2, this.y + this.height/2);
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }
        
        class Base {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = BLOCK_SIZE;
                this.height = BLOCK_SIZE;
                this.health = owner === 'player' ? 1 : 3;
                this.maxHealth = this.health;
                this.owner = owner;
            }
            
            hit() {
                this.health--;
            }
            
            render(ctx) {
                if (this.health > 0) {
                    ctx.fillStyle = this.owner === 'player' ? '#FFD700' : '#FF4444';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 12px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.owner === 'player' ? 'ü¶Ö' : '‚ö°', this.x + this.width/2, this.y + this.height/2);
                    
                    if (this.owner !== 'player' && this.health < this.maxHealth) {
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(this.x, this.y - 4, this.width, 2);
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(this.x, this.y - 4, (this.width * this.health) / this.maxHealth, 2);
                    }
                } else {
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillText('üíÄ', this.x + this.width/2, this.y + this.height/2);
                }
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }
        
        const game = new TankGame();
    </script>
</body>
</html>

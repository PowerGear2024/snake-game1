<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Battle City Mobile - HD</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        
        body {
            background: linear-gradient(45deg, #0f0f23, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
            overflow: hidden;
        }
        
        .game-container {
            position: relative;
            margin: 10px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border: 3px solid #ecf0f1;
        }
        
        #gameCanvas {
            display: block;
            background: #1a2f1a;
            max-width: 100vw;
            max-height: 70vh;
        }
        
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #f39c12;
            font-size: 14px;
            font-weight: bold;
            color: #f39c12;
            z-index: 10;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 300px;
            padding: 20px;
            background: rgba(0,0,0,0.9);
            margin-top: 10px;
            border-radius: 15px;
        }
        
        .dpad {
            position: relative;
            width: 140px;
            height: 140px;
        }
        
        .dpad-btn {
            position: absolute;
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border: 3px solid #ecf0f1;
            border-radius: 12px;
            font-size: 24px;
            font-weight: bold;
            color: #ecf0f1;
            cursor: pointer;
            transition: all 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .dpad-btn:active {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .dpad-up { 
            top: 0; 
            left: 50px; 
            width: 40px; 
            height: 40px; 
        }
        .dpad-down { 
            bottom: 0; 
            left: 50px; 
            width: 40px; 
            height: 40px; 
        }
        .dpad-left { 
            top: 50px; 
            left: 0; 
            width: 40px; 
            height: 40px; 
        }
        .dpad-right { 
            top: 50px; 
            right: 0; 
            width: 40px; 
            height: 40px; 
        }
        .dpad-center { 
            top: 50px; 
            left: 50px; 
            width: 40px; 
            height: 40px; 
            background: rgba(52,73,94,0.3); 
            border: 2px solid #555;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(44,62,80,0.95), rgba(52,73,94,0.95));
            padding: 30px;
            border: 3px solid #f39c12;
            border-radius: 15px;
            text-align: center;
            display: none;
            box-shadow: 0 0 40px rgba(243,156,18,0.5);
            z-index: 20;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: #2c3e50;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 15px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
            transform: translateY(-2px);
        }

        .level-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #3498db;
            color: #3498db;
            font-size: 12px;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .controls {
                padding: 15px;
            }
            
            .dpad {
                width: 120px;
                height: 120px;
            }
            
            .dpad-btn {
                font-size: 18px;
            }
            
            .dpad-up, .dpad-down, .dpad-left, .dpad-right { 
                width: 35px; 
                height: 35px; 
            }
            .dpad-center { 
                top: 42px; 
                left: 42px; 
                width: 36px; 
                height: 36px; 
            }
            .dpad-up { left: 42px; }
            .dpad-down { left: 42px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="520" height="520"></canvas>
        
        <div class="hud">
            <div>üèÜ –û—á–∫–∏: <span id="score">0</span></div>
            <div>üíö –ñ–∏–∑–Ω–∏: <span id="lives">3</span></div>
            <div>‚≠ê –£—Ä–æ–≤–µ–Ω—å: <span id="powerLevel">0</span></div>
            <div id="powerUpStatus"></div>
        </div>
        
        <div class="level-info">
            <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
            <div>–í—Ä–∞–≥–∏: <span id="enemies">10</span></div>
            <div id="levelType">–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π</div>
        </div>
        
        <div class="game-over" id="gameOver">
            <h2>üéØ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h2>
            <div>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á—ë—Ç: <span id="finalScore">0</span></div>
            <button class="restart-btn" onclick="game.restart()">üöÄ –ù–û–í–ê–Ø –ò–ì–†–ê</button>
        </div>
    </div>

    <div class="controls">
        <div class="dpad">
            <button class="dpad-btn dpad-up" data-direction="up">‚ñ≤</button>
            <button class="dpad-btn dpad-down" data-direction="down">‚ñº</button>
            <button class="dpad-btn dpad-left" data-direction="left">‚óÄ</button>
            <button class="dpad-btn dpad-right" data-direction="right">‚ñ∂</button>
            <div class="dpad-center"></div>
        </div>
    </div>

    <script>
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏–≥—Ä—ã
        const BLOCK_SIZE = 20;
        const GRID_WIDTH = 26;
        const GRID_HEIGHT = 26;
        
        const ENEMY_TYPES = {
            BASIC: { speed: 1, health: 1, points: 100, color: '#FF4444', size: 18 },
            FAST: { speed: 2, health: 1, points: 200, color: '#FF8844', size: 16 },
            POWER: { speed: 1, health: 3, points: 300, color: '#44FF44', size: 20 },
            ARMOR: { speed: 1, health: 2, points: 400, color: '#FFFF44', size: 19 }
        };

        const POWERUP_TYPES = {
            STAR: { name: '–ó–≤–µ–∑–¥–∞', effect: 'upgrade', duration: -1, icon: '‚≠ê' },
            HELMET: { name: '–®–ª–µ–º', effect: 'shield', duration: 8000, icon: 'üõ°Ô∏è' },
            SHOVEL: { name: '–õ–æ–ø–∞—Ç–∞', effect: 'fortify', duration: 15000, icon: 'üõ†Ô∏è' },
            GRENADE: { name: '–ì—Ä–∞–Ω–∞—Ç–∞', effect: 'destroy_all', duration: -1, icon: 'üí£' },
            TANK: { name: '–¢–∞–Ω–∫', effect: 'extra_life', duration: -1, icon: 'üöó' },
            CLOCK: { name: '–ß–∞—Å—ã', effect: 'freeze', duration: 6000, icon: '‚è∞' }
        };

        // –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –∏–≥—Ä—ã
        class TankGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameState = 'playing';
                this.enemiesRemaining = 10;
                this.enemiesOnField = 0;
                this.maxEnemiesOnField = 3;
                this.enemySpawnTimer = 0;
                this.enemySpawnDelay = 120;
                
                // –ú–∞—Å—Å–∏–≤—ã –æ–±—ä–µ–∫—Ç–æ–≤
                this.bullets = [];
                this.enemyBullets = [];
                this.enemies = [];
                this.explosions = [];
                this.powerUps = [];
                this.walls = [];
                this.grass = [];
                this.water = [];
                this.particles = [];
                this.enemyBases = [];
                
                // –°–ø–∞–≤–Ω —Ç–æ—á–∫–∏ –≤—Ä–∞–≥–æ–≤
                this.enemySpawnPoints = [
                    { x: BLOCK_SIZE, y: BLOCK_SIZE },
                    { x: 12 * BLOCK_SIZE, y: BLOCK_SIZE },
                    { x: 23 * BLOCK_SIZE, y: BLOCK_SIZE }
                ];
                
                // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–∫–∞ –∏ –±–∞–∑—É
                this.player = new Tank(12 * BLOCK_SIZE, 22 * BLOCK_SIZE, 'player');
                this.playerBase = new Base(12 * BLOCK_SIZE, 24 * BLOCK_SIZE, 'player');
                
                // –°–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä–æ–∫–∞
                this.playerPowerUps = {
                    shield: 180, // –ù–∞—á–∞–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞
                    level: 0,
                    frozen: false
                };
                
                // –°–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                this.touchControls = {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                };
                
                this.init();
                this.bindEvents();
                this.gameLoop();
                
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–ø–∞–≤–Ω–∏–º –≤—Ä–∞–≥–æ–≤
                setTimeout(() => this.forceSpawnEnemies(), 1000);
            }
            
            init() {
                this.createLevel();
                this.updateHUD();
                this.enemySpawnTimer = 0;
            }
            
            forceSpawnEnemies() {
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–µ–º –≤—Ä–∞–≥–æ–≤ –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
                for (let i = 0; i < 3; i++) {
                    if (this.enemiesRemaining > 0) {
                        this.spawnEnemy();
                    }
                }
            }
            
            createLevel() {
                this.walls = [];
                this.grass = [];
                this.water = [];
                this.enemyBases = [];
                
                // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∫–∞—Ä—Ç—É
                this.createSimpleLevel();
                this.createBorders();
                this.createPlayerBaseProtection();
            }
            
            createSimpleLevel() {
                // –°–æ–∑–¥–∞–µ–º –±–∞–∑—ã –≤—Ä–∞–≥–æ–≤
                this.enemyBases.push(new Base(2 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                this.enemyBases.push(new Base(22 * BLOCK_SIZE, 2 * BLOCK_SIZE, 'enemy'));
                
                // –ü—Ä–æ—Å—Ç—ã–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
                const obstacles = [
                    // –ö–∏—Ä–ø–∏—á–Ω—ã–µ —Å—Ç–µ–Ω—ã
                    [5, 5], [6, 5], [7, 5],
                    [17, 5], [18, 5], [19, 5],
                    [5, 8], [6, 8], [7, 8],
                    [17, 8], [18, 8], [19, 8],
                    
                    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
                    [11, 10], [12, 10], [13, 10],
                    [11, 11], [12, 11], [13, 11],
                    
                    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–µ–Ω—ã
                    [3, 15], [4, 15], [5, 15],
                    [19, 15], [20, 15], [21, 15],
                ];
                
                obstacles.forEach(([x, y]) => {
                    this.walls.push({
                        x: x * BLOCK_SIZE,
                        y: y * BLOCK_SIZE,
                        destructible: true,
                        health: 1,
                        maxHealth: 1
                    });
                });
                
                // –í–æ–¥–∞
                const waterAreas = [
                    [9, 12], [10, 12], [14, 12], [15, 12]
                ];
                
                waterAreas.forEach(([x, y]) => {
                    this.water.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
                
                // –¢—Ä–∞–≤–∞
                const grassAreas = [
                    [2, 7], [3, 7], [21, 7], [22, 7],
                    [8, 14], [9, 14], [15, 14], [16, 14]
                ];
                
                grassAreas.forEach(([x, y]) => {
                    this.grass.push({x: x * BLOCK_SIZE, y: y * BLOCK_SIZE});
                });
            }
            
            createBorders() {
                // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ (—Å –ø—Ä–æ—Ö–æ–¥–∞–º–∏ –¥–ª—è —Å–ø–∞–≤–Ω–∞)
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (x < 1 || (x > 2 && x < 11) || (x > 13 && x < 22) || x > 23) {
                        this.walls.push({
                            x: x * BLOCK_SIZE, y: 0,
                            destructible: false, health: -1
                        });
                    }
                }
                
                // –û—Å—Ç–∞–ª—å–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã
                for (let x = 0; x < GRID_WIDTH; x++) {
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: (GRID_HEIGHT-1) * BLOCK_SIZE,
                        destructible: false, health: -1
                    });
                }
                
                for (let y = 1; y < GRID_HEIGHT-1; y++) {
                    this.walls.push({
                        x: 0, y: y * BLOCK_SIZE,
                        destructible: false, health: -1
                    });
                    this.walls.push({
                        x: (GRID_WIDTH-1) * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: false, health: -1
                    });
                }
            }
            
            createPlayerBaseProtection() {
                const baseProtection = [
                    [11, 22], [12, 22], [13, 22],
                    [11, 23], [13, 23],
                    [11, 25], [13, 25]
                ];
                
                baseProtection.forEach(([x, y]) => {
                    this.walls.push({
                        x: x * BLOCK_SIZE, y: y * BLOCK_SIZE,
                        destructible: true, health: 1, maxHealth: 1
                    });
                });
            }
            
            bindEvents() {
                this.keys = {};
                
                // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'KeyP') this.togglePause();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // –°–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                const dpadButtons = document.querySelectorAll('.dpad-btn');
                dpadButtons.forEach(btn => {
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction;
                        if (direction) {
                            this.touchControls[direction] = true;
                        }
                    });
                    
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction;
                        if (direction) {
                            this.touchControls[direction] = false;
                        }
                    });
                    
                    // –î–ª—è –º—ã—à–∏ —Ç–æ–∂–µ
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction;
                        if (direction) {
                            this.touchControls[direction] = true;
                        }
                    });
                    
                    btn.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        const direction = btn.dataset.direction;
                        if (direction) {
                            this.touchControls[direction] = false;
                        }
                    });
                });
                
                // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∑–∞–ª–∏–ø–∞–Ω–∏–µ –∫–Ω–æ–ø–æ–∫
                document.addEventListener('mouseup', () => {
                    Object.keys(this.touchControls).forEach(key => {
                        this.touchControls[key] = false;
                    });
                });
            }
            
            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                }
            }
            
            update() {
                if (this.gameState !== 'playing') return;
                
                this.updatePowerUps();
                this.updateEnemySpawn();
                
                this.player.update(this);
                
                if (!this.playerPowerUps.frozen) {
                    this.enemies.forEach(enemy => enemy.update(this));
                }
                
                this.bullets = this.bullets.filter(bullet => bullet.update(this));
                this.enemyBullets = this.enemyBullets.filter(bullet => bullet.update(this));
                this.explosions = this.explosions.filter(explosion => explosion.update());
                this.particles = this.particles.filter(particle => particle.update());
                
                this.checkCollisions();
                this.checkGameConditions();
            }
            
            updatePowerUps() {
                if (this.playerPowerUps.shield > 0) {
                    this.playerPowerUps.shield--;
                }
                
                if (this.playerPowerUps.frozen && Date.now() > this.playerPowerUps.frozenUntil) {
                    this.playerPowerUps.frozen = false;
                }
                
                this.updatePowerUpDisplay();
            }
            
            updatePowerUpDisplay() {
                const statusElement = document.getElementById('powerUpStatus');
                let status = '';
                
                if (this.playerPowerUps.shield > 0) status += 'üõ°Ô∏è ';
                if (this.playerPowerUps.level > 0) status += '‚≠ê'.repeat(this.playerPowerUps.level) + ' ';
                if (this.playerPowerUps.frozen) status += '‚ùÑÔ∏è ';
                
                statusElement.textContent = status;
                document.getElementById('powerLevel').textContent = this.playerPowerUps.level;
            }
            
            updateEnemySpawn() {
                if (this.enemiesRemaining > 0 && this.enemiesOnField < this.maxEnemiesOnField) {
                    this.enemySpawnTimer++;
                    if (this.enemySpawnTimer >= this.enemySpawnDelay) {
                        this.spawnEnemy();
                        this.enemySpawnTimer = 0;
                    }
                }
            }
            
            spawnEnemy() {
                if (this.enemiesRemaining <= 0) return;
                
                const spawnPoint = this.enemySpawnPoints[Math.floor(Math.random() * this.enemySpawnPoints.length)];
                
                if (this.checkCollision(spawnPoint.x, spawnPoint.y, BLOCK_SIZE, BLOCK_SIZE)) {
                    return;
                }
                
                let enemyType = 'BASIC';
                const rand = Math.random();
                if (rand < 0.15) enemyType = 'POWER';
                else if (rand < 0.35) enemyType = 'ARMOR';
                else if (rand < 0.6) enemyType = 'FAST';
                
                const hasPowerUp = (10 - this.enemiesRemaining + 1) % 3 === 0;
                
                const enemy = new Tank(spawnPoint.x, spawnPoint.y, 'enemy', enemyType, hasPowerUp);
                this.enemies.push(enemy);
                this.enemiesRemaining--;
                this.enemiesOnField++;
                
                this.explosions.push(new Explosion(spawnPoint.x, spawnPoint.y, 'spawn'));
                
                console.log('–í—Ä–∞–≥ –∑–∞—Å–ø–∞–≤–Ω–µ–Ω!', enemyType, '–Ω–∞ –ø–æ–∑–∏—Ü–∏–∏', spawnPoint.x, spawnPoint.y);
            }
            
            checkCollisions() {
                // –ü—É–ª–∏ –∏–≥—Ä–æ–∫–∞ vs –≤—Ä–∞–≥–∏
                this.bullets.forEach((bullet, bulletIndex) => {
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (this.isColliding(bullet, enemy)) {
                            this.bullets.splice(bulletIndex, 1);
                            
                            enemy.hit();
                            if (enemy.health <= 0) {
                                if (enemy.hasPowerUp) {
                                    this.createPowerUp(enemy.x, enemy.y);
                                }
                                
                                this.enemies.splice(enemyIndex, 1);
                                this.enemiesOnField--;
                                this.explosions.push(new Explosion(enemy.x, enemy.y));
                                this.createParticles(enemy.x + BLOCK_SIZE/2, enemy.y + BLOCK_SIZE/2, '#FF6600');
                                this.score += ENEMY_TYPES[enemy.enemyType].points;
                                this.updateHUD();
                            }
                        }
                    });
                });
                
                // –ü—É–ª–∏ vs –±–∞–∑—ã –≤—Ä–∞–≥–æ–≤
                this.bullets.forEach((bullet, bulletIndex) => {
                    this.enemyBases.forEach((base, baseIndex) => {
                        if (this.isColliding(bullet, base)) {
                            this.bullets.splice(bulletIndex, 1);
                            base.hit();
                            this.explosions.push(new Explosion(base.x, base.y));
                            this.score += 1000;
                            this.updateHUD();
                            
                            if (base.health <= 0) {
                                this.enemyBases.splice(baseIndex, 1);
                            }
                        }
                    });
                });
                
                // –ü—É–ª–∏ –≤—Ä–∞–≥–æ–≤ vs –∏–≥—Ä–æ–∫
                this.enemyBullets.forEach((bullet, bulletIndex) => {
                    if (this.isColliding(bullet, this.player)) {
                        this.enemyBullets.splice(bulletIndex, 1);
                        
                        if (this.playerPowerUps.shield > 0) {
                            this.playerPowerUps.shield = 0;
                        } else {
                            this.player.hit();
                            this.explosions.push(new Explosion(this.player.x, this.player.y));
                            this.createParticles(this.player.x + BLOCK_SIZE/2, this.player.y + BLOCK_SIZE/2, '#00FF00');
                            this.lives--;
                            this.playerPowerUps.shield = 120;
                            this.updateHUD();
                        }
                    }
                });
                
                // –ü—É–ª–∏ vs –±–∞–∑–∞ –∏–≥—Ä–æ–∫–∞
                [...this.bullets, ...this.enemyBullets].forEach((bullet, index, array) => {
                    if (this.isColliding(bullet, this.playerBase)) {
                        array.splice(index, 1);
                        this.playerBase.hit();
                        this.explosions.push(new Explosion(this.playerBase.x, this.playerBase.y));
                        if (this.playerBase.health <= 0) {
                            this.gameOver();
                        }
                    }
                });
                
                // –ü—É–ª–∏ vs —Å—Ç–µ–Ω—ã
                [...this.bullets, ...this.enemyBullets].forEach((bullet, index, array) => {
                    this.walls.forEach((wall, wallIndex) => {
                        if (this.isColliding(bullet, wall)) {
                            array.splice(index, 1);
                            if (wall.destructible) {
                                wall.health--;
                                if (wall.health <= 0) {
                                    this.walls.splice(wallIndex, 1);
                                    this.explosions.push(new Explosion(wall.x, wall.y, 'small'));
                                    this.createParticles(wall.x + BLOCK_SIZE/2, wall.y + BLOCK_SIZE/2, '#8B4513');
                                }
                            }
                        }
                    });
                });
                
                // –ò–≥—Ä–æ–∫ vs –±–æ–Ω—É—Å—ã
                this.powerUps.forEach((powerUp, index) => {
                    if (this.isColliding(this.player, powerUp)) {
                        this.powerUps.splice(index, 1);
                        this.applyPowerUp(powerUp.type);
                        this.explosions.push(new Explosion(powerUp.x, powerUp.y, 'pickup'));
                        this.score += 500;
                        this.updateHUD();
                    }
                });
            }
            
            createPowerUp(x, y) {
                const types = Object.keys(POWERUP_TYPES);
                const randomType = types[Math.floor(Math.random() * types.length)];
                this.powerUps.push(new PowerUp(x, y, randomType));
            }
            
            applyPowerUp(type) {
                const powerUp = POWERUP_TYPES[type];
                
                switch (powerUp.effect) {
                    case 'upgrade':
                        this.playerPowerUps.level = Math.min(3, this.playerPowerUps.level + 1);
                        this.player.upgrade();
                        break;
                    case 'shield':
                        this.playerPowerUps.shield = powerUp.duration / 16.67;
                        break;
                    case 'destroy_all':
                        this.destroyAllEnemies();
                        break;
                    case 'extra_life':
                        this.lives++;
                        break;
                    case 'freeze':
                        this.playerPowerUps.frozen = true;
                        this.playerPowerUps.frozenUntil = Date.now() + powerUp.duration;
                        break;
                }
            }
            
            destroyAllEnemies() {
                this.enemies.forEach(enemy => {
                    this.explosions.push(new Explosion(enemy.x, enemy.y));
                    this.score += ENEMY_TYPES[enemy.enemyType].points;
                });
                this.enemiesOnField = 0;
                this.enemies = [];
                this.updateHUD();
            }
            
            createParticles(x, y, color) {
                for (let i = 0; i < 6; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }
            
            checkGameConditions() {
                if (this.lives <= 0 || this.playerBase.health <= 0) {
                    this.gameOver();
                }
                
                if ((this.enemiesRemaining === 0 && this.enemies.length === 0) || this.enemyBases.length === 0) {
                    this.nextLevel();
                }
            }
            
            nextLevel() {
                this.level++;
                this.enemiesRemaining = 10 + this.level * 3;
                this.enemiesOnField = 0;
                this.powerUps = [];
                this.updateHUD();
                this.createLevel();
                this.player.x = 12 * BLOCK_SIZE;
                this.player.y = 22 * BLOCK_SIZE;
                this.playerBase = new Base(12 * BLOCK_SIZE, 24 * BLOCK_SIZE, 'player');
                
                // –§–æ—Ä—Å–∏—Ä—É–µ–º —Å–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤
                setTimeout(() => this.forceSpawnEnemies(), 500);
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restart() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.enemiesRemaining = 10;
                this.enemiesOnField = 0;
                this.gameState = 'playing';
                this.bullets = [];
                this.enemyBullets = [];
                this.enemies = [];
                this.explosions = [];
                this.particles = [];
                this.powerUps = [];
                this.playerPowerUps = { shield: 180, level: 0, frozen: false };
                this.player = new Tank(12 * BLOCK_SIZE, 22 * BLOCK_SIZE, 'player');
                this.playerBase = new Base(12 * BLOCK_SIZE, 24 * BLOCK_SIZE, 'player');
                this.init();
                document.getElementById('gameOver').style.display = 'none';
                
                // –§–æ—Ä—Å–∏—Ä—É–µ–º —Å–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤
                setTimeout(() => this.forceSpawnEnemies(), 1000);
            }
            
            updateHUD() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                document.getElementById('enemies').textContent = this.enemiesRemaining + this.enemiesOnField;
            }
            
            isColliding(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
            
            checkCollision(x, y, width, height) {
                const testObj = {x, y, width, height};
                
                if (this.walls.some(wall => this.isColliding(testObj, wall))) return true;
                if (this.water.some(water => this.isColliding(testObj, water))) return true;
                if (this.isColliding(testObj, this.playerBase)) return true;
                if (this.enemyBases.some(base => this.isColliding(testObj, base))) return true;
                if (this.enemies.some(enemy => this.isColliding(testObj, enemy))) return true;
                
                return false;
            }
            
            render() {
                // –û—á–∏—â–∞–µ–º —ç–∫—Ä–∞–Ω —Å –∫—Ä–∞—Å–∏–≤—ã–º —Ñ–æ–Ω–æ–º
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, '#0a2e0a');
                gradient.addColorStop(1, '#051a05');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // –†–∏—Å—É–µ–º –≤–æ–¥—É
                this.water.forEach(water => this.drawWater(water));
                
                // –†–∏—Å—É–µ–º —Å—Ç–µ–Ω—ã
                this.walls.forEach(wall => this.drawWall(wall));
                
                // –†–∏—Å—É–µ–º –±–∞–∑—ã
                this.playerBase.render(this.ctx);
                this.enemyBases.forEach(base => base.render(this.ctx));
                
                // –†–∏—Å—É–µ–º —Ç–∞–Ω–∫–∏ (–í–ê–ñ–ù–û!)
                this.player.render(this.ctx);
                this.enemies.forEach(enemy => enemy.render(this.ctx));
                
                // –†–∏—Å—É–µ–º —Ç—Ä–∞–≤—É –ø–æ–≤–µ—Ä—Ö —Ç–∞–Ω–∫–æ–≤
                this.grass.forEach(grass => this.drawGrass(grass));
                
                // –†–∏—Å—É–µ–º –ø—É–ª–∏
                this.bullets.forEach(bullet => bullet.render(this.ctx));
                this.enemyBullets.forEach(bullet => bullet.render(this.ctx));
                
                // –†–∏—Å—É–µ–º –±–æ–Ω—É—Å—ã
                this.powerUps.forEach(powerUp => powerUp.render(this.ctx));
                
                // –†–∏—Å—É–µ–º –≤–∑—Ä—ã–≤—ã –∏ —á–∞—Å—Ç–∏—Ü—ã
                this.explosions.forEach(explosion => explosion.render(this.ctx));
                this.particles.forEach(particle => particle.render(this.ctx));
                
                // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                this.ctx.fillStyle = '#FFF';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`–ò–≥—Ä–æ–∫: (${Math.floor(this.player.x/BLOCK_SIZE)}, ${Math.floor(this.player.y/BLOCK_SIZE)})`, 10, this.height - 30);
                this.ctx.fillText(`–í—Ä–∞–≥–æ–≤ –Ω–∞ –ø–æ–ª–µ: ${this.enemies.length}`, 10, this.height - 15);
                
                // –ü–∞—É–∑–∞
                if (this.gameState === 'paused') {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.ctx.fillStyle = '#f39c12';
                    this.ctx.font = 'bold 32px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('‚è∏Ô∏è –ü–ê–£–ó–ê', this.width/2, this.height/2);
                }
            }
            
            drawWall(wall) {
                if (wall.destructible) {
                    // –ö–∏—Ä–ø–∏—á–Ω–∞—è —Å—Ç–µ–Ω–∞
                    const gradient = this.ctx.createLinearGradient(wall.x, wall.y, wall.x + BLOCK_SIZE, wall.y + BLOCK_SIZE);
                    gradient.addColorStop(0, '#CD853F');
                    gradient.addColorStop(1, '#8B4513');
                    this.ctx.fillStyle = gradient;
                } else {
                    // –°—Ç–∞–ª—å–Ω–∞—è —Å—Ç–µ–Ω–∞
                    const gradient = this.ctx.createLinearGradient(wall.x, wall.y, wall.x + BLOCK_SIZE, wall.y + BLOCK_SIZE);
                    gradient.addColorStop(0, '#C0C0C0');
                    gradient.addColorStop(1, '#2F4F4F');
                    this.ctx.fillStyle = gradient;
                }
                
                this.ctx.fillRect(wall.x, wall.y, BLOCK_SIZE, BLOCK_SIZE);
                
                // –¢–µ–Ω–∏ –∏ –±–ª–∏–∫–∏
                this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                this.ctx.fillRect(wall.x, wall.y, BLOCK_SIZE, 2);
                this.ctx.fillRect(wall.x, wall.y, 2, BLOCK_SIZE);
                
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fillRect(wall.x, wall.y + BLOCK_SIZE - 2, BLOCK_SIZE, 2);
                this.ctx.fillRect(wall.x + BLOCK_SIZE - 2, wall.y, 2, BLOCK_SIZE);
                
                // –†–∞–º–∫–∞
                this.ctx.strokeStyle = wall.destructible ? '#654321' : '#4F4F4F';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(wall.x, wall.y, BLOCK_SIZE, BLOCK_SIZE);
            }
            
            drawGrass(grass) {
                const gradient = this.ctx.createRadialGradient(
                    grass.x + BLOCK_SIZE/2, grass.y + BLOCK_SIZE/2, 0,
                    grass.x + BLOCK_SIZE/2, grass.y + BLOCK_SIZE/2, BLOCK_SIZE/2
                );
                gradient.addColorStop(0, '#90EE90');
                gradient.addColorStop(0.7, '#32CD32');
                gradient.addColorStop(1, '#228B22');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(grass.x, grass.y, BLOCK_SIZE, BLOCK_SIZE);
            }
            
            drawWater(water) {
                const time = Date.now() * 0.003;
                const wave1 = Math.sin(time + water.x * 0.1) * 0.3 + 0.7;
                
                const gradient = this.ctx.createRadialGradient(
                    water.x + BLOCK_SIZE/2, water.y + BLOCK_SIZE/2, 0,
                    water.x + BLOCK_SIZE/2, water.y + BLOCK_SIZE/2, BLOCK_SIZE/2
                );
                gradient.addColorStop(0, `rgba(70, 130, 180, ${wave1})`);
                gradient.addColorStop(1, 'rgba(0, 100, 200, 0.9)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(water.x, water.y, BLOCK_SIZE, BLOCK_SIZE);
                
                this.ctx.strokeStyle = '#1E90FF';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(water.x, water.y, BLOCK_SIZE, BLOCK_SIZE);
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // –ö–ª–∞—Å—Å —Ç–∞–Ω–∫–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Å—Ç—Ä–µ–ª—å–±–æ–π
        class Tank {
            constructor(x, y, type, enemyType = 'BASIC', hasPowerUp = false) {
                this.x = x;
                this.y = y;
                this.width = BLOCK_SIZE;
                this.height = BLOCK_SIZE;
                this.type = type;
                this.enemyType = enemyType;
                this.hasPowerUp = hasPowerUp;
                this.direction = type === 'player' ? 0 : 2;
                this.lastShot = 0;
                this.shootCooldown = type === 'player' ? 400 : 600;
                this.level = 0;
                this.animationFrame = 0;
                
                if (type === 'player') {
                    this.speed = 2;
                    this.health = 1;
                    this.maxBullets = 1;
                } else {
                    const stats = ENEMY_TYPES[enemyType];
                    this.speed = stats.speed;
                    this.health = stats.health;
                    this.maxHealth = stats.health;
                    this.color = stats.color;
                    this.maxBullets = 1;
                    this.size = stats.size;
                    
                    this.aiTimer = 0;
                    this.aiDirection = this.direction;
                    this.aiChangeTimer = 0;
                    this.targetDirection = this.direction;
                }
            }
            
            upgrade() {
                this.level = Math.min(3, this.level + 1);
                if (this.level >= 1) this.maxBullets = 2;
                if (this.level >= 2) this.speed = 3;
                if (this.level >= 3) this.shootCooldown = 250;
            }
            
            update(game) {
                this.animationFrame++;
                if (this.type === 'player') {
                    this.updatePlayer(game);
                } else {
                    this.updateAI(game);
                }
                
                // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –°–¢–†–ï–õ–¨–ë–ê
                if (Date.now() - this.lastShot > this.shootCooldown) {
                    if (this.type === 'player') {
                        if (game.bullets.length < this.maxBullets) {
                            this.shoot(game);
                        }
                    } else {
                        if (game.enemyBullets.length < 6) {
                            this.shoot(game);
                        }
                    }
                }
            }
            
            updatePlayer(game) {
                let newX = this.x;
                let newY = this.y;
                let moved = false;
                
                // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ + —Å–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                if (game.keys['KeyW'] || game.keys['ArrowUp'] || game.touchControls.up) {
                    this.direction = 0;
                    newY -= this.speed;
                    moved = true;
                }
                if (game.keys['KeyS'] || game.keys['ArrowDown'] || game.touchControls.down) {
                    this.direction = 2;
                    newY += this.speed;
                    moved = true;
                }
                if (game.keys['KeyA'] || game.keys['ArrowLeft'] || game.touchControls.left) {
                    this.direction = 3;
                    newX -= this.speed;
                    moved = true;
                }
                if (game.keys['KeyD'] || game.keys['ArrowRight'] || game.touchControls.right) {
                    this.direction = 1;
                    newX += this.speed;
                    moved = true;
                }
                
                if (!game.checkCollision(newX, newY, this.width, this.height)) {
                    this.x = newX;
                    this.y = newY;
                }
            }
            
            updateAI(game) {
                this.aiTimer++;
                this.aiChangeTimer++;
                
                if (this.aiChangeTimer > 60 + Math.random() * 60) {
                    this.targetDirection = Math.floor(Math.random() * 4);
                    this.aiChangeTimer = 0;
                }
                
                let newX = this.x;
                let newY = this.y;
                
                this.direction = this.targetDirection;
                
                switch (this.direction) {
                    case 0: newY -= this.speed; break;
                    case 1: newX += this.speed; break;
                    case 2: newY += this.speed; break;
                    case 3: newX -= this.speed; break;
                }
                
                if (!game.checkCollision(newX, newY, this.width, this.height)) {
                    this.x = newX;
                    this.y = newY;
                } else {
                    this.targetDirection = Math.floor(Math.random() * 4);
                    this.aiChangeTimer = 0;
                }
            }
            
            shoot(game) {
                this.lastShot = Date.now();
                
                let bulletX = this.x + this.width / 2;
                let bulletY = this.y + this.height / 2;
                
                switch (this.direction) {
                    case 0: bulletY = this.y; break;
                    case 1: bulletX = this.x + this.width; break;
                    case 2: bulletY = this.y + this.height; break;
                    case 3: bulletX = this.x; break;
                }
                
                const bullet = new Bullet(bulletX, bulletY, this.direction, this.type);
                
                if (this.type === 'player') {
                    game.bullets.push(bullet);
                } else {
                    game.enemyBullets.push(bullet);
                }
            }
            
            hit() {
                this.health--;
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.direction * Math.PI / 2);
                
                // –†–∞–∑–º–µ—Ä —Ç–∞–Ω–∫–∞
                const tankSize = this.type === 'player' ? BLOCK_SIZE - 2 : (this.size || BLOCK_SIZE - 4);
                
                // –ì—É—Å–µ–Ω–∏—Ü—ã
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(-tankSize/2 - 1, -tankSize/2 - 1, tankSize + 2, 4);
                ctx.fillRect(-tankSize/2 - 1, tankSize/2 - 3, tankSize + 2, 4);
                
                // –¢–µ–ª–æ —Ç–∞–Ω–∫–∞
                let bodyColor1, bodyColor2;
                
                if (this.type === 'player') {
                    switch (this.level) {
                        case 0: bodyColor1 = '#FFD700'; bodyColor2 = '#FFA500'; break;
                        case 1: bodyColor1 = '#32CD32'; bodyColor2 = '#228B22'; break;
                        case 2: bodyColor1 = '#00BFFF'; bodyColor2 = '#1E90FF'; break;
                        case 3: bodyColor1 = '#FF69B4'; bodyColor2 = '#FF1493'; break;
                    }
                } else {
                    bodyColor1 = this.color || '#FF4444';
                    bodyColor2 = this.adjustBrightness(bodyColor1, -0.3);
                }
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, tankSize/2);
                gradient.addColorStop(0, bodyColor1);
                gradient.addColorStop(1, bodyColor2);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(-tankSize/2, -tankSize/2, tankSize, tankSize);
                
                // –ë–∞—à–Ω—è
                ctx.fillStyle = bodyColor2;
                ctx.beginPath();
                ctx.arc(0, 0, tankSize/4, 0, Math.PI * 2);
                ctx.fill();
                
                // –ü—É—à–∫–∞
                ctx.fillStyle = '#2F2F2F';
                ctx.fillRect(-2, -tankSize/2 - 4, 4, 8);
                
                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–¥–æ—Ä–æ–≤—å—è –¥–ª—è –≤—Ä–∞–≥–æ–≤
                if (this.type === 'enemy' && this.health < this.maxHealth) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(-tankSize/2, -tankSize/2 - 6, tankSize, 2);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(-tankSize/2, -tankSize/2 - 6, (tankSize * this.health) / this.maxHealth, 2);
                }
                
                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –±–æ–Ω—É—Å–∞
                if (this.type === 'enemy' && this.hasPowerUp) {
                    const pulse = Math.sin(this.animationFrame * 0.2) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚òÖ', 0, -tankSize/2 - 10);
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
                
                // –©–∏—Ç –∏–≥—Ä–æ–∫–∞
                if (this.type === 'player' && game.playerPowerUps.shield > 0) {
                    const shieldAlpha = (Math.sin(Date.now() * 0.03) + 1) / 2;
                    ctx.globalAlpha = shieldAlpha * 0.8;
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2 + 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
            
            adjustBrightness(color, amount) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }
        
        // –ö–ª–∞—Å—Å –ø—É–ª–∏
        class Bullet {
            constructor(x, y, direction, owner) {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 4;
                this.direction = direction;
                this.speed = 6;
                this.owner = owner;
                
                this.vx = 0;
                this.vy = 0;
                
                switch (direction) {
                    case 0: this.vy = -this.speed; break;
                    case 1: this.vx = this.speed; break;
                    case 2: this.vy = this.speed; break;
                    case 3: this.vx = -this.speed; break;
                }
            }
            
            update(game) {
                this.x += this.vx;
                this.y += this.vy;
                
                return this.x > 0 && this.x < game.width && 
                       this.y > 0 && this.y < game.height;
            }
            
            render(ctx) {
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.width/2);
                if (this.owner === 'player') {
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(1, '#FFFF00');
                } else {
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(1, '#FF6600');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width/2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // –ö–ª–∞—Å—Å –≤–∑—Ä—ã–≤–∞
        class Explosion {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = type === 'spawn' ? 20 : type === 'small' ? 12 : type === 'pickup' ? 8 : 20;
                this.maxLife = this.life;
                this.radius = 0;
                this.maxRadius = type === 'small' ? 12 : type === 'pickup' ? 8 : 20;
            }
            
            update() {
                this.life--;
                this.radius = ((this.maxLife - this.life) / this.maxLife) * this.maxRadius;
                return this.life > 0;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                
                let colors;
                if (this.type === 'spawn') {
                    colors = ['#FFFFFF', '#00FFFF'];
                } else if (this.type === 'pickup') {
                    colors = ['#FFFFFF', '#FFD700'];
                } else {
                    colors = ['#FFFFFF', '#FFFF00', '#FF6600'];
                }
                
                const gradient = ctx.createRadialGradient(
                    this.x + BLOCK_SIZE/2, this.y + BLOCK_SIZE/2, 0,
                    this.x + BLOCK_SIZE/2, this.y + BLOCK_SIZE/2, this.radius
                );
                
                colors.forEach((color, index) => {
                    gradient.addColorStop(index / (colors.length - 1), color);
                });
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x + BLOCK_SIZE/2, this.y + BLOCK_SIZE/2, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            }
        }
        
        // –ö–ª–∞—Å—Å —á–∞—Å—Ç–∏—Ü
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 15;
                this.maxLife = 15;
                this.color = color;
                this.size = Math.random() * 2 + 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }
            
            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        // –ö–ª–∞—Å—Å –±–æ–Ω—É—Å–∞
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = BLOCK_SIZE;
                this.height = BLOCK_SIZE;
                this.type = type;
                this.animationTimer = 0;
                this.lifeTime = 400;
            }
            
            update() {
                this.animationTimer++;
                this.lifeTime--;
                return this.lifeTime > 0;
            }
            
            render(ctx) {
                if (this.lifeTime < 120 && Math.floor(this.animationTimer / 8) % 2) {
                    return;
                }
                
                const powerUp = POWERUP_TYPES[this.type];
                const pulse = Math.sin(this.animationTimer * 0.2) * 0.1 + 1;
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.scale(pulse, pulse);
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(1, '#FF8C00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.width/2 - 1, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#FF4500';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerUp.icon, 0, 0);
                
                ctx.restore();
            }
        }
        
        // –ö–ª–∞—Å—Å –±–∞–∑—ã
        class Base {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = BLOCK_SIZE;
                this.height = BLOCK_SIZE;
                this.health = owner === 'player' ? 1 : 3;
                this.maxHealth = this.health;
                this.owner = owner;
            }
            
            hit() {
                this.health--;
            }
            
            render(ctx) {
                if (this.health > 0) {
                    let gradient;
                    if (this.owner === 'player') {
                        gradient = ctx.createRadialGradient(
                            this.x + this.width/2, this.y + this.height/2, 0,
                            this.x + this.width/2, this.y + this.height/2, this.width/2
                        );
                        gradient.addColorStop(0, '#FFD700');
                        gradient.addColorStop(1, '#FF8C00');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        
                        ctx.fillStyle = '#8B4513';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ü¶Ö', this.x + this.width/2, this.y + this.height/2);
                    } else {
                        gradient = ctx.createRadialGradient(
                            this.x + this.width/2, this.y + this.height/2, 0,
                            this.x + this.width/2, this.y + this.height/2, this.width/2
                        );
                        gradient.addColorStop(0, '#FF4444');
                        gradient.addColorStop(1, '#AA2222');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('‚ö°', this.x + this.width/2, this.y + this.height/2);
                        
                        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–¥–æ—Ä–æ–≤—å—è
                        if (this.health < this.maxHealth) {
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(this.x, this.y - 4, this.width, 2);
                            ctx.fillStyle = '#00FF00';
                            ctx.fillRect(this.x, this.y - 4, (this.width * this.health) / this.maxHealth, 2);
                        }
                    }
                } else {
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', this.x + this.width/2, this.y + this.height/2);
                }
                
                ctx.strokeStyle = this.health > 0 ? (this.owner === 'player' ? '#B8860B' : '#8B0000') : '#8B0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        const game = new TankGame();
        
        // –û—Ç–ª–∞–¥–∫–∞
        console.log('–ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞!');
        console.log('–ò–≥—Ä–æ–∫ —Å–æ–∑–¥–∞–Ω –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏:', game.player.x, game.player.y);
        console.log('–í—Ä–∞–≥–∏ –±—É–¥—É—Ç —Å–ø–∞–≤–Ω–∏—Ç—å—Å—è...');
    </script>
</body>
</html>

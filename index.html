
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import json
import logging
from datetime import datetime, timedelta

# Настройка логирования
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ВАЖНО: Замените на ваш токен от @BotFather
BOT_TOKEN = "7500806601:AAG3nSdkrXc6WBQKojXg-Nx6gAAGEcF4v4M"

# URL вашего веб-приложения
WEBAPP_URL = "https://powergear2024.github.io/snake-game1/"

# Словарь для хранения статистики игроков
player_stats = {}

class PlayerStats:
    def __init__(self):
        self.total_games = 0
        self.best_score = 0
        self.best_length = 0
        self.best_level = 0
        self.best_combo = 0
        self.total_score = 0
        self.total_food_eaten = 0
        self.achievements = set()
        self.last_played = None
        self.games_today = 0
        self.daily_reset = None

def get_player_stats(user_id):
    if user_id not in player_stats:
        player_stats[user_id] = PlayerStats()
    
    # Сброс ежедневной статистики
    stats = player_stats[user_id]
    today = datetime.now().date()
    if stats.daily_reset != today:
        stats.games_today = 0
        stats.daily_reset = today
    
    return stats

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /start - главное меню игры"""
    user = update.effective_user
    chat = update.effective_chat
    stats = get_player_stats(user.id)
    
    # Проверяем тип чата
    if chat.type == 'private':
        # Личный чат - полное меню с WebApp
        welcome_text = f"""🌌 Добро пожаловать в ЗМЕЙКУ MEGA, {user.first_name}! 

🚀 **НОВЫЕ ВОЗМОЖНОСТИ:**
🎮 Виртуальный джойстик управления
🌟 5 типов волшебной еды с бонусами  
🌀 Порталы для телепортации
🔥 Система комбо множителей
💎 Эффекты призрака и ускорения
🏆 Система достижений

📊 **ВАША СТАТИСТИКА:**
🎯 Лучший результат: {stats.best_score} очков
🐍 Максимальная длина: {stats.best_length}
🚀 Высший уровень: {stats.best_level}
🔥 Лучшее комбо: x{stats.best_combo}
🎮 Игр сыграно: {stats.total_games}

Готовы покорить космос? 🌌"""

        # Создаем кнопку для запуска WebApp (только в личном чате)
        keyboard = [
            [InlineKeyboardButton("🎮 ИГРАТЬ В ЗМЕЙКУ MEGA", web_app=WebAppInfo(url=WEBAPP_URL))],
            [InlineKeyboardButton("🏆 Топ игроков", callback_data="leaderboard"),
             InlineKeyboardButton("📊 Статистика", callback_data="stats")],
            [InlineKeyboardButton("❓ Справка", callback_data="help"),
             InlineKeyboardButton("🏅 Достижения", callback_data="achievements")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
    else:
        # Группа/канал - упрощенное меню без WebApp
        welcome_text = f"""🐍 **ЗМЕЙКА MEGA в группе!** 🚀

Привет, {user.first_name}! Я - игровой бот Змейка MEGA!

🎮 **Что я умею:**
• Веду рейтинг лучших игроков группы
• Показываю статистику и достижения
• Провожу турниры и соревнования

🌟 **Для игры** напишите мне в личные сообщения: @{context.bot.username}

⚡ **Команды в группе:**
/top - 🏆 Рейтинг игроков группы
/stats - 📊 Ваша статистика  
/rules - 📋 Правила игры
/help - ❓ Полная справка

**Начните играть в личных сообщениях и соревнуйтесь с участниками группы!** 🏆"""

        # Простые кнопки для группы (без WebApp)
        keyboard = [
            [InlineKeyboardButton("💬 Играть в личке", url=f"https://t.me/{context.bot.username}?start=group_{chat.id}")],
            [InlineKeyboardButton("🏆 Рейтинг группы", callback_data="leaderboard"),
             InlineKeyboardButton("📋 Правила", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(welcome_text, reply_markup=reply_markup)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /help - подробная справка"""
    help_text = """🐍 **СПРАВКА ПО ЗМЕЙКЕ MEGA** 🚀

🎮 **УПРАВЛЕНИЕ:**
• Виртуальный джойстик или стрелки клавиатуры
• Центральная кнопка - пауза/старт
• Свайпы на мобильном устройстве

🍎 **ТИПЫ ЕДЫ:**
🍎 Красные яблоки - +10 очков
🌟 Золотые звезды - +25 очков + замедление
💎 Алмазы - +50 очков + эффект призрака  
⚡ Молнии - +15 очков + ускорение
🌀 Порталы - +30 очков + телепортация

🔥 **СИСТЕМА КОМБО:**
• Быстрое поедание еды увеличивает множитель
• Комбо x3+ дает бонусные очки
• Чем быстрее едите, тем больше очков!

🏆 **ДОСТИЖЕНИЯ:**
🍽️ Первый пир - съесть 15 фруктов
🏆 Мастер - набрать 300 очков
🐍 Гигантская змея - длина 20+ сегментов
💨 Демон скорости - достичь 6 уровня
🔥 Мастер комбо - комбо x5

⚠️ **ПРЕПЯТСТВИЯ:**
🧱 Красные блоки появляются каждые 150 очков
💎 Эффект призрака позволяет проходить сквозь них

🌌 **ЭФФЕКТЫ:**
• Звездное небо и космические туманности
• Следы от движения змейки
• Частицы при поедании еды
• Свечение при активных бонусах

Удачной игры! 🍀"""
    
    # Отправляем в зависимости от типа update
    if hasattr(update, 'message'):
        await update.message.reply_text(help_text)
    else:
        await update.edit_message_text(help_text)

async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /top - топ игроков"""
    if not player_stats:
        message_text = "🏆 Пока никто не играл! Станьте первым!"
    else:
        # Сортируем игроков по лучшему результату
        sorted_players = sorted(
            [(user_id, stats) for user_id, stats in player_stats.items()], 
            key=lambda x: x[1].best_score, 
            reverse=True
        )
        
        message_text = "🏆 **ТОП 10 ИГРОКОВ** 🏆\n\n"
        
        for i, (user_id, stats) in enumerate(sorted_players[:10], 1):
            try:
                user_info = await context.bot.get_chat(user_id)
                username = user_info.first_name or f"Игрок{user_id}"
            except:
                username = f"Игрок{user_id}"
            
            medal = "🥇" if i == 1 else "🥈" if i == 2 else "🥉" if i == 3 else f"{i}."
            
            message_text += (
                f"{medal} **{username}**\n"
                f"   🎯 {stats.best_score} очков | 🐍 {stats.best_length} длина\n"
                f"   🚀 {stats.best_level} уровень | 🔥 x{stats.best_combo} комбо\n\n"
            )
    
    # Отправляем в зависимости от типа update
    if hasattr(update, 'message'):
        await update.message.reply_text(message_text, parse_mode='Markdown')
    else:
        await update.edit_message_text(message_text, parse_mode='Markdown')

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /stats - личная статистика"""
    # Поддержка как команд, так и callback кнопок
    if hasattr(update, 'effective_user'):
        user = update.effective_user
    else:
        user = update.from_user
    stats = get_player_stats(user.id)
    
    if stats.total_games == 0:
        await update.message.reply_text("📊 Вы еще не играли! Нажмите /start чтобы начать.")
        return
    
    avg_score = stats.total_score // stats.total_games if stats.total_games > 0 else 0
    
    # Ранг игрока
    all_scores = [s.best_score for s in player_stats.values() if s.best_score > 0]
    all_scores.sort(reverse=True)
    rank = all_scores.index(stats.best_score) + 1 if stats.best_score in all_scores else len(all_scores) + 1
    
    stats_text = f"""📊 **СТАТИСТИКА {user.first_name}** 

🏅 **РЕЙТИНГ:** #{rank} из {len(player_stats)}

🎯 **РЕКОРДЫ:**
• Лучший результат: {stats.best_score} очков
• Максимальная длина: {stats.best_length} сегментов  
• Высший уровень: {stats.best_level}
• Лучшее комбо: x{stats.best_combo}

📈 **ОБЩАЯ СТАТИСТИКА:**
• Всего игр: {stats.total_games}
• Игр сегодня: {stats.games_today}
• Общие очки: {stats.total_score:,}
• Средний результат: {avg_score} очков

🏆 **ДОСТИЖЕНИЯ:** {len(stats.achievements)}/5

{f"🎮 Последняя игра: {stats.last_played.strftime('%d.%m %H:%M')}" if stats.last_played else ""}"""
    
    # Определяем тип чата для правильных кнопок
    if hasattr(update, 'effective_chat'):
        chat_type = update.effective_chat.type
    elif hasattr(update, 'message'):
        chat_type = update.message.chat.type
    else:
        chat_type = 'private'  # По умолчанию
    
    if chat_type == 'private':
        # Личный чат - кнопка с WebApp
        keyboard = [
            [InlineKeyboardButton("🎮 Играть снова", web_app=WebAppInfo(url=WEBAPP_URL))],
            [InlineKeyboardButton("🏆 Топ игроков", callback_data="leaderboard")]
        ]
    else:
        # Группа - обычные кнопки
        keyboard = [
            [InlineKeyboardButton("🎮 Играть в личке", url=f"https://t.me/{context.bot.username}")],
            [InlineKeyboardButton("🏆 Рейтинг группы", callback_data="leaderboard")]
        ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Отправляем в зависимости от типа update
    if hasattr(update, 'message'):
        await update.message.reply_text(stats_text, reply_markup=reply_markup, parse_mode='Markdown')
    else:
        await update.edit_message_text(stats_text, reply_markup=reply_markup, parse_mode='Markdown')

async def rules_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Команда /rules - правила игры"""
    rules_text = """📋 **ПРАВИЛА ЗМЕЙКИ MEGA** 

🎯 **ЦЕЛЬ ИГРЫ:**
Управляйте змейкой, ешьте еду и набирайте очки, избегая столкновений со стенами, препятствиями и собственным телом.

🐍 **МЕХАНИКА:**
• Змейка постоянно движется в выбранном направлении
• При поедании еды змейка увеличивается в длину
• Скорость игры увеличивается с уровнем
• Каждые 6 съеденных фруктов = новый уровень

🔥 **СИСТЕМА КОМБО:**
• Съедайте еду быстро для увеличения множителя
• Комбо x2 и выше дают бонусные очки
• Пауза между поеданием > 3 сек сбрасывает комбо

🌀 **ПОРТАЛЫ:**
• Редкая еда, создающая 2 портала на 15 секунд
• Вход в один портал телепортирует в другой
• Используйте для избежания препятствий

⚡ **БОНУСНЫЕ ЭФФЕКТЫ:**
• 🌟 Замедление - проще управлять
• 💎 Призрак - проходите сквозь стены и препятствия  
• ⚡ Ускорение - быстрый набор очков

🏆 **ОЧКИ:**
• Обычная еда: +10 очков
• Золотая еда: +25 очков  
• Молния: +15 очков
• Алмазы: +50 очков
• Порталы: +30 очков
• Комбо множитель добавляет бонусы!

Удачи в покорении космоса! 🚀"""
    
    await update.message.reply_text(rules_text, parse_mode='Markdown')

async def handle_callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик callback кнопок"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "leaderboard":
        await leaderboard(query, context)
    elif query.data == "stats":
        await stats_command(query, context)
    elif query.data == "help":
        await help_command(query, context)
    elif query.data == "achievements":
        await show_achievements(query, context)

async def show_achievements(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Показать достижения игрока"""
    # Поддержка как команд, так и callback кнопок
    if hasattr(update, 'effective_user'):
        user = update.effective_user
    else:
        user = update.from_user
    stats = get_player_stats(user.id)
    
    all_achievements = {
        'first_feast': '🍽️ Первый пир - съесть 15 фруктов',
        'score_300': '🏆 Мастер - набрать 300 очков',
        'long_snake': '🐍 Гигантская змея - длина 20+ сегментов',
        'speed_demon': '💨 Демон скорости - достичь 6 уровня',
        'combo_master': '🔥 Мастер комбо - комбо x5'
    }
    
    achieved_text = "🏅 **ПОЛУЧЕННЫЕ ДОСТИЖЕНИЯ:**\n"
    locked_text = "\n🔒 **НЕ ПОЛУЧЕНЫ:**\n"
    
    for achievement_id, description in all_achievements.items():
        if achievement_id in stats.achievements:
            achieved_text += f"✅ {description}\n"
        else:
            locked_text += f"❌ {description}\n"
    
    if len(stats.achievements) == 0:
        achieved_text += "Пока нет достижений. Играйте больше!\n"
    
    achievements_text = achieved_text + locked_text + f"\n🏆 Прогресс: {len(stats.achievements)}/5 достижений"
    
    # Определяем тип чата для правильных кнопок
    if hasattr(update, 'effective_chat'):
        chat_type = update.effective_chat.type
    elif hasattr(update, 'message'):
        chat_type = update.message.chat.type
    else:
        chat_type = 'private'
    
    if chat_type == 'private':
        # Личный чат - кнопка с WebApp
        keyboard = [
            [InlineKeyboardButton("🎮 Играть", web_app=WebAppInfo(url=WEBAPP_URL))]
        ]
    else:
        # Группа - обычная кнопка
        keyboard = [
            [InlineKeyboardButton("🎮 Играть в личке", url=f"https://t.me/{context.bot.username}")]
        ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Отправляем в зависимости от типа update
    if hasattr(update, 'message'):
        await update.message.reply_text(achievements_text, reply_markup=reply_markup, parse_mode='Markdown')
    else:
        await update.edit_message_text(achievements_text, reply_markup=reply_markup, parse_mode='Markdown')

async def handle_webapp_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка данных от WebApp"""
    user = update.effective_user
    stats = get_player_stats(user.id)
    
    try:
        data = json.loads(update.effective_message.web_app_data.data)
        action = data.get('action')
        
        if action == 'game_over':
            score = data.get('score', 0)
            level = data.get('level', 1)
            max_length = data.get('maxLength', 1)
            max_combo = data.get('maxCombo', 0)
            
            # Обновляем статистику
            stats.total_games += 1
            stats.games_today += 1
            stats.total_score += score
            stats.total_food_eaten += data.get('totalFoodEaten', 0)  # Добавляем общее количество еды
            stats.last_played = datetime.now()
            
            # Обновляем рекорды
            is_new_record = False
            records_broken = []
            
            if score > stats.best_score:
                stats.best_score = score
                is_new_record = True
                records_broken.append(f"🎯 Новый рекорд очков: {score}")
            
            if max_length > stats.best_length:
                stats.best_length = max_length
                records_broken.append(f"🐍 Новая максимальная длина: {max_length}")
            
            if level > stats.best_level:
                stats.best_level = level
                records_broken.append(f"🚀 Новый высший уровень: {level}")
                
            if max_combo > stats.best_combo:
                stats.best_combo = max_combo
                records_broken.append(f"🔥 Новое лучшее комбо: x{max_combo}")
            
            # Проверяем достижения
            new_achievements = []
            if stats.total_food_eaten >= 15 and 'first_feast' not in stats.achievements:
                stats.achievements.add('first_feast')
                new_achievements.append('🍽️ Первый пир')
                
            if score >= 300 and 'score_300' not in stats.achievements:
                stats.achievements.add('score_300')
                new_achievements.append('🏆 Мастер')
            
            if max_length >= 20 and 'long_snake' not in stats.achievements:
                stats.achievements.add('long_snake')
                new_achievements.append('🐍 Гигантская змея')
            
            if level >= 6 and 'speed_demon' not in stats.achievements:
                stats.achievements.add('speed_demon')
                new_achievements.append('💨 Демон скорости')
                
            if max_combo >= 5 and 'combo_master' not in stats.achievements:
                stats.achievements.add('combo_master')
                new_achievements.append('🔥 Мастер комбо')
            
            # Формируем сообщение
            if is_new_record:
                message = f"🎉 **НОВЫЙ РЕКОРД!** 🎉\n\n"
            else:
                message = f"🎮 **Игра окончена!** \n\n"
            
            message += f"🎯 Результат: **{score} очков**\n"
            message += f"🐍 Длина: {max_length} | 🚀 Уровень: {level}\n"
            message += f"🔥 Лучшее комбо: x{max_combo}\n\n"
            
            if records_broken:
                message += "🏆 **Новые рекорды:**\n" + "\n".join(records_broken) + "\n\n"
            
            if new_achievements:
                message += "🏅 **Новые достижения:**\n" + "\n".join(new_achievements) + "\n\n"
            
            # Ранг игрока
            all_scores = [s.best_score for s in player_stats.values()]
            all_scores.sort(reverse=True)
            rank = all_scores.index(stats.best_score) + 1
            message += f"📊 Ваш рейтинг: **#{rank}** из {len(player_stats)}"
            
            keyboard = [
                [InlineKeyboardButton("🔄 Играть снова", web_app=WebAppInfo(url=WEBAPP_URL))],
                [InlineKeyboardButton("🏆 Топ игроков", callback_data="leaderboard"),
                 InlineKeyboardButton("📊 Статистика", callback_data="stats")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.effective_message.reply_text(message, reply_markup=reply_markup, parse_mode='Markdown')
            
        elif action == 'share_score':
            score = data.get('score', 0)
            level = data.get('level', 1)
            max_length = data.get('maxLength', 1)
            max_combo = data.get('maxCombo', 0)
            
            share_message = (
                f"🐍 Я набрал {score} очков в ЗМЕЙКЕ MEGA! 🚀\n"
                f"🎯 Уровень {level} | 🐍 Длина {max_length} | 🔥 Комбо x{max_combo}\n\n"
                f"Сможешь побить мой рекорд? 😎"
            )
            
            keyboard = [
                [InlineKeyboardButton("📤 Поделиться в чате", 
                                    switch_inline_query=share_message)],
                [InlineKeyboardButton("🎮 Играть самому", web_app=WebAppInfo(url=WEBAPP_URL))]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.effective_message.reply_text(
                f"🎉 Отличный результат! {score} очков!\n\nПоделитесь своим достижением:",
                reply_markup=reply_markup
            )
            
    except json.JSONDecodeError:
        await update.effective_message.reply_text("❌ Ошибка при получении данных от игры")
    except Exception as e:
        logger.error(f"Ошибка обработки WebApp данных: {e}")

async def new_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик добавления новых участников в чат"""
    message = update.message
    new_members = message.new_chat_members
    
    # Проверяем, добавили ли нашего бота
    bot_added = any(member.id == context.bot.id for member in new_members)
    
    if bot_added:
        # Бота добавили в группу - отправляем приветствие
        welcome_text = f"""🎉 **Привет, {message.chat.title}!** 🎉

🐍 Я - **ЗМЕЙКА MEGA** - самый крутой игровой бот в Telegram!

🚀 **Что я принес в вашу группу:**
🏆 Рейтинг лучших игроков группы
📊 Статистику и достижения каждого
🎮 Соревнования и турниры
🌟 Систему достижений и наград

🎯 **Как начать играть:**
1️⃣ Напишите мне в личку: @{context.bot.username}
2️⃣ Играйте и набирайте очки
3️⃣ Соревнуйтесь с участниками группы!

⚡ **Команды для группы:**
/top - 🏆 Рейтинг игроков группы  
/stats - 📊 Ваша статистика
/rules - 📋 Правила игры
/help - ❓ Полная справка

**Пусть лучший победит!** 🏆✨"""

        keyboard = [
            [InlineKeyboardButton("🎮 Начать играть", url=f"https://t.me/{context.bot.username}?start=group_{message.chat.id}")],
            [InlineKeyboardButton("🏆 Рейтинг", callback_data="leaderboard"),
             InlineKeyboardButton("📋 Правила", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await message.reply_text(welcome_text, reply_markup=reply_markup)
    
    # Приветствуем обычных новых участников
    else:
        for member in new_members:
            if not member.is_bot:
                welcome_text = f"""👋 Добро пожаловать в группу, {member.first_name}!

🐍 Здесь живет игровой бот **ЗМЕЙКА MEGA**!

🎮 Хочешь сразиться с участниками группы? 
Напиши мне в личку: @{context.bot.username} и начни играть!

🏆 Посмотреть рейтинг группы: /top"""

                await message.reply_text(welcome_text)

async def post_init(application):
    """Настройка бота после инициализации"""
    try:
        commands = [
            BotCommand("start", "🎮 Начать игру"),
            BotCommand("help", "❓ Справка по игре"),
            BotCommand("top", "🏆 Топ игроков"), 
            BotCommand("stats", "📊 Моя статистика"),
            BotCommand("rules", "📋 Правила игры")
        ]
        await application.bot.set_my_commands(commands)
        print("✅ Команды бота настроены")
    except Exception as e:
        print(f"⚠️ Ошибка настройки команд: {e}")
    """Настройка бота после инициализации"""
    try:
        commands = [
            BotCommand("start", "🎮 Начать игру"),
            BotCommand("help", "❓ Справка по игре"),
            BotCommand("top", "🏆 Топ игроков"), 
            BotCommand("stats", "📊 Моя статистика"),
            BotCommand("rules", "📋 Правила игры")
        ]
        await application.bot.set_my_commands(commands)
        print("✅ Команды бота настроены")
    except Exception as e:
        print(f"⚠️ Ошибка настройки команд: {e}")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик ошибок"""
    logger.warning(f'Update {update} caused error {context.error}')

def main():
    """Главная функция запуска бота"""
    print("🐍 Запуск Telegram WebApp бота ЗМЕЙКА MEGA...")
    
    if BOT_TOKEN == "ВАШ_ТОКЕН_БОТА":
        print("❌ ОШИБКА: Необходимо заменить BOT_TOKEN на реальный токен!")
        print("📝 Получите токен у @BotFather в Telegram")
        return
    
    if WEBAPP_URL == "https://yourusername.github.io/snake-game/index.html":
        print("⚠️  ВНИМАНИЕ: Необходимо заменить WEBAPP_URL на реальный URL!")
        print("🌐 Разместите HTML-файл игры на GitHub Pages или другом хостинге")
    
    # Создаем приложение
    application = Application.builder().token(BOT_TOKEN).post_init(post_init).build()
    
    # Добавляем обработчики команд
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("top", leaderboard))
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CommandHandler("rules", rules_command))
    
    # Обработчик добавления бота в группу
    application.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, new_chat_member))
    
    # Обработчики callback кнопок и WebApp данных
    application.add_handler(CallbackQueryHandler(handle_callback_query))
    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_webapp_data))
    
    # Обработчик ошибок
    application.add_error_handler(error_handler)
    
    print("✅ Бот настроен!")
    print("🎮 Команды: /start /help /top /stats /rules")
    print("🚀 Пользователи могут запускать игру через /start")
    print("🛑 Для остановки нажмите Ctrl+C")
    
    # Запускаем бота простым способом
    print("🔄 Запуск polling...")
    try:
        application.run_polling(drop_pending_updates=True)
    except KeyboardInterrupt:
        print("\n🛑 Бот остановлен пользователем")
    except Exception as e:
        print(f"❌ Ошибка запуска: {e}")
        print("💡 Убедитесь что:")
        print("   1. Токен правильный")
        print("   2. Интернет соединение работает") 
        print("   3. Бот не запущен в другом месте")

if __name__ == "__main__":
    main()
